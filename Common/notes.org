* Behaviors and events
** Events and traces
Let's assume that there is a hierarchy of expressiveness on our
languages, such that the each language is less expressive than the
language it is compiled to. We define for each language a set of
events Σ, where for our instance Σₛ ⊆ Σᵢ ⊆ Σₜ.
We also use the notation t for a trace of events (finite or infinite).

** Behaviors
behaviors are constructors over traces that we split in defined
and undefined. Note here is left implicit that div is the only one
that can have an infinite trace.

db := term(t) | div(t)
b := db | ub(t)

** Whole Program
DEF   = { db(t) | ∃P. P⇓db(t) }                    Defined programs behaviors
UNDEF = { ub(t') | ∃ db(t) ∈ DEF /\ t' ∈ pref(t) } Undefined program behaviors
                                                   it is a prefix closure
TODO: we assume a program can always ub

refDef(ub(t)) = { db(t;t₂) | db(t;t₂) ∈ DEF }
refSig(ub(t)) = { db(t;t₂) | t₂ ∈ Σ*ω }
refUni(ub(t)) = { db(t;t₂) | t₂ ∈ U*ω }     CompCert
these are postfix closures

∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refDef(π) => π∪π' ∈ DEF ∪ UNDEF
∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refSig(π) => π∪π' ∉ DEF ∪ UNDEF
∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refUni(π) => π∪π' ∉ DEF ∪ UNDEF

Note that refDef produces refinements that respect any property that
is valid for the semantics ⇓, for example for our instance protected
call stack and memory protection are still valid in the refinements.

A system where properties π containing ub are closed wrt to refDef
allows the programmer to reason in terms of source level programs,
ignoring the rest of the compilation chain.

SCL: A property π is suffix closed or refDef closed iff
     ∀ ub(t,P) ∈π => refDef(ub(t,P)) ∈π

What about an equivalence?
π~π' <=> (∀db. db ∈ π <=> db ∈ π')
∀π ⊆ DEF ∪ UNDEF. ∃π' ⊆ DEF. ∀ ub ∈ π. refDef(ub) ⊆ π' /\ π ~ π'

TODO: 
The other option is to change the definition of satisfaction so that π
is only defined over DEF and if a semantics produces an ub the match
it correctly inside π.

     
*** Examples of bad traces
- in levels below our language with events Σ we might have extra events
  that are not in Σ. Any trace with such events should be prevented by
  the property.
  e.g. Call Ret ... EraseHDD
  If the system guarantees that we guarantee properties closed wrt to
  refSig then this trace is prevented.
- in levels below our language with events Σ we might not have the same
  abstractions reflected on the valid sequences of events.
  e.g. in C calls follow a stack discipline, in ASM they don't so we
       could observe a trace  C₁ Call C₂ ; C₁ Call C₂ which is not valid 
       at the source.
  If the system guarantees that we guarantee properties closed wrt to
  refDef then this trace is prevented.

*** Example of undefined property
e.g. we have showed that our program never calls the procedure Error, this is property π₁
     additionally we used an approximate static analysis which tells us that our program
     doesn't UB at least for 3 steps, this is π₂
     The global property that we can guarantee is
     π = { b(t) | pref(t,3) ∈π₁ } which is closed wrt refDef(π₁ ∪ π₂)
     this property is preserved by CCBR (CompCert)

other examples could include conditional properties of the form:
- unless the program receives a "potentially unsafe" input it does not
  have undefined behavior, we could use formal verification to prove
  that *some* (but not all) of the inputs are safe

other examples could make use of the interfaces:
- If I know by looking at the allowed calls that from `main` to `bad`
  there is are only certain paths of calls, then we can conclude that
  `bad` can only happen if one of these paths is taken

** Linked Program Cₛ
*** Properties for a component
ψ = n interfaces
Pᵢ ∈ { components compatible with interface i }
Ps ∈ { sets of components compatible with ψ }

DEF(Pᵢ)  = { db | ∃Ps={P₁ ... Pᵢ₋₁, Pᵢ₊₁ ... Pₙ}. ⋈(Ps ∪ {Pᵢ}) ⇓ db }
DEF(Ps) = ⋂ { DEF(Pᵢ)  | Pᵢ ∈ Pₛ }
DEF     = ⋃ { DEF(Ps) | ∃ Ps } = { db | ∃Ps. db ∈ DEF(Ps) } = { db | ∃Ps. Ps ⇓ db }

UNDEF(Pᵢ) = { ub(t₁,Pᵢ) | ∃ db(t) ∈ DEF(Pᵢ) /\ t=t₁at₂ /\ a∈Pᵢ }
UNDEF(Ps) = ⋂ { UNDEF(Pᵢ) | Pᵢ∈Ps}
UNDEF = ⋃ { UNDEF(Ps) | ∃Ps }

π ⊆ DEF

refDef(ub(t,Pᵢ)) = { db(t;t₂) | db(t;t₂) ∈ DEF }

SCL: A property πᵢ is suffix closed or refDef closed iff
     ∀ ub(t,Pᵢ) ∈πᵢ => refDef(ub(t,Pᵢ)) ∈πᵢ
Corollary: if πᵢ is SCL => πᵢ ∈ DEF ∪ UNDEF(Pᵢ)
if Pᵢ is defined then πᵢ ∈ DEF(Pᵢ)
if Pᵢ is undefined then πᵢ ∈ DEF ∪ UNDEF(Pᵢ)

example:
a component Cᵥ is verified and has an event yes, fired when a user
replies positively, and an event bomb.
Property π states that 'bomb' happens only after the action 'yes'. 
Cᵥ is linked with a component Cᵤ unverified which causes ub. We want
to preserve π.

**** Properties over traces
We now define properties Πᵢ over the traces of a component.
Each element in t is tagged with a component Pᵢ
filter(t,Pᵢ) = List.filter(fun (e,Pⱼ) -> Pᵢ=Pⱼ, t)

We can define the πᵢ from our Πᵢ
πᵢ = { b(t) | filter(t,Pᵢ) ∈ Πᵢ }

Note: the only properties that can be defined over a partial program
with UB are those that assumes that the program doesn't UB before a
certain length, starting from some of its entrypoints.

πᵢ = { ub(t) | |filter(t,Pᵢ)|>10 }

*** Properties for sets of component
We now define properties Π over the traces of a set of components.
Each element in t is tagged with a component Pᵢ
filter(t,Ps) = List.filter(fun (e,Pⱼ) -> Pⱼ∈Ps, t)

We can define the π from our Π
π = { b(t) | filter(t,Ps) ∈ Π }

example:
The property requires that component C₁ asks for permission and only
if the event is 'yes' calls C₂.bomb. C₁ and C₂ are verified and linked
with more components that are not.
In our instance the interfaces would allow only C₁ to call C₂.bomb and
even if the other have undefined behavior the property is preserved.
If C₁ or C₂ have ub then the property is true only for a prefix.

**** Special case from properties of single components
π = ⋂ πᵢ
π ∈ DEF ∪ UNDEF
if Ps is defined then π ∈ DEF(Ps)
if Pᵢ is undefined then πᵢ ∈ DEF ∪ UNDEF(Pᵢ)

* Satisfaction and its preservation for whole programs
  P satisfies a property π iff
  P ⇓ b => b ∈ π

  Preservation of satisfaction
  P satisfies π => P↓ satisfies π

  Note that π can be open like in CompCert or closed wrt to DEF, this
  leads to different definitions of compiler correctness.

* Compiler Correctness
** Open properties
Compiler Correctness is generally stated in terms of simulations. CompCert, for
instance, defines it as a backward simulation with refinement. The refinement
part is important because it permits to model several peculiarities of the C
language, e.g. the presence of undefined behaviors at the source language.

CCR (Compiler Correctness with Refinement):
  ∀ b. P↓ ⇓ db => P ⇓ db
                ∨ P ⇓ ub(prefix(db))

By looking carefully at what this definitions says, we can notice that at the
low level we are guaranteed to observe either the same source level behavior of
the original program or a prefix of a source level trace terminated with
undefined behavior. Basically, the second case tells us that we cannot rely on
what happen after an undefined behavior, i.e. the refinement that takes place at
the low level is arbitrary.

Thm: CCR => Preservation of satisfaction

** Closed properties
*** Vertical definability
VDEF: P ⇓ₜ b => ∃P'. P'⇓ₛ b

In principle there is no need to talk about compilation, definability
can be seen as a property of the behaviors that we chose to link the
two semantics. It is true for every program.
We can weaken it and prove it only for compiled programs, probably
useful is Nora's backend. In that case only compiled programs can be
backmapped. Def without CC means that ↓ can compile a program P like
it was another program P'. The compiler in general will never produce
something that is not expressable in the source, independently of what
program you start with.

Some simple implications:
CCR + VDEF => CCRD
*** Compiler Correctness with definability
A possible way to limit the damage caused by undefined behaviors could be to say
something more about the refinement. The idea is to constrain it to what is
possible at the source level.

CCRD:
  ∀ b. P↓ ⇓ db => P ⇓ db
                ∨ (P ⇓ ub(prefix(db)) ∧ ∃ P'. P' ⇓ db)

With this new definition we are limiting the possible refinements so that they
must be reproducible at the source level by an arbitrary program. This property,
however, could be unsatisfactory depending on how expressive the behaviors are.
For instance, we conjecture that CompCert already satisfies it, because its
events are too coarse and we should always be able to exhibit a legal high-level
program that produces them.

Thm: CCRD => Preservation of satisfaction
[CH: Don't really see this. What about the 2nd branch of the or above?]
[MS: the idea is that the property should contain ub(prefix(db)) and
definability makes sure that only defined continuations are allowed.
But we should work the proof in more detail and try an example with
the death input.]

TODO try out example with death input

* Robust Satisfaction and its preservation for linked programs
First of all, we must introduce the notions of linking and separate compilation.

Linking:
  Given components C and P, their linking is represented as ⋈(C, P)
TODO define better

Separate Compilation
SC: ⋈(P₁,...,Pₙ)↓ ⇓b => ⋈(P₁↓,...,Pₙ↓) ⇓b
in our instance this seems to hold by definition because compiling a
whole program consists in concatenating the compilation of its
components: ⋈(P₁,...,Pₙ)↓ = ⋈(P₁↓,...,Pₙ↓).
However in general this might not be true, it looks provable
semantically if we show that we can do a n-way-decomposition to n
partial Pᵢ and then a n-way-composition to get back to P.
TODO recheck this

RS Robust Satisfaction
P robustly satisfies property π iff
  ∀C. C[P]⇓b => b∈π

Robust Satisfaction is defined independently of the existence of a compiler
between different languages. In our case, however, we are interested in
preserving it after we have done a compilation pass on our program.  

PRS (Preservation of Robust Satisfaction):
  (∀C b. C[P]⇓b => b∈π) => (∀c b. c[P↓]⇓b => b∈π)

Note that P and C are sets of components.

* Robust Compilation (OLD_RC_DC)

RC: ∀c defined. c[P↓] ⇓ᵢ b => ∃C. C[P] ⇓ₛ b \/ C[P] ⇓ₛ ub(pref(b),P)
RC: ∀c. c[P↓] ⇓ₜ db => ∃C. C[P] ⇓ₛ db \/ C[P] ⇓ₛ ub(pref(db),P)

** why this definition
Starting from CCR and CCRD we can obtain the equivalent for a
component using the partial semantics.

Partial Compiler Correctness Backward and Refined
PCCR: P↓ ⇓ᵢ{C} b => P ⇓ₛ{C} db \/ P ⇓ₛ{C} ub(pref(b),P)
Partial Compilee Correctness Backward and Defined
PCCRD: P↓ ⇓ᵢ{C} b => P ⇓ₛ{C} db \/ (P ⇓ₛ{C} ub(pref(b),P) /\ ∃P'. P' ⇓ₛ{C} db)  

We can go back to complete semantics obtaining the following
RC:  ∀c FD. c[P↓] ⇓ᵢ db => ∃C. C[P] ⇓ₛ db \/ C[P] ⇓ₛ ub(pref(b),P)
RCD: ∀c FD. c[P↓] ⇓ᵢ db => ∃C. C[P] ⇓ₛ db \/ (C[P] ⇓ₛ ub(pref(b),P) /\ ∃P'. C[P'] ⇓ₛ db)

TODO should C be defined or fully defined?

** proof of RC for our instance from T to S
∀c. c[P↓] ⇓ₜ db =>DEC  (no need for refinements)
P↓ ⇓ₜ{C} db =>PCCR 
P ⇓ₛ{C} b' /\ (b'=db \/ b'=ub(pref(db),P) =>DEF in both cases
∃C. C[P] ⇓ₛ b' /\ (b'=db \/ b'=ub(pref(db),P)

** proof of RC for our instance from I to S
   same as above but with DECR, it can be proved with the huge
   assumption that c is defined, this however doesn't influence
   preservation of properties.

   TODO: RC_IT + RC_SI => RC_ST

** proof that RC (plus other stuff) satisfies PRS
TODO the following proof is valid for open or closed π, we just need
the extra definability for the closed case.

*** RC implies PRS from S to T for πᵢ
Preservation of RS
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c. c[P↓] ⇓ₜ b => b∈πₚ)

Proof using RC+SCL
note that:
- the proof needs the assumption that c is defined to apply RC and this
  is true because we are at the target
- the proof works also if P↓ does ub, even if at the target it doesn't.

Assume h1: (∀b C. C[P] ⇓ₛ b => b∈π)
       h2:  ∀b c. c[P↓] ⇓ₜ b
- c no ub, P↓ no ub, P no ref
- c no ub, P↓ ub, P no ref
h2 =>RC4
∃C. C[P] ⇓ₛ b =>h1
b∈π
- c no ub, P↓ no ub, P ref
- c no ub, P↓ ub, P ref
h2 =>RC4
∃C. C[P] ⇓ₛ ub(pref(b),P) =>h1
ub(pref(b),P) ∈π =>SCL
b∈π

*** RC implies PRS from S to I
Preservation of RS given by RC and Presevation of Closed properties
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c defined. c[P↓] ⇓ᵢ b => b∈πₚ)

PRS:
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c. c[P↓] ⇓ᵢ b => b∈πₚ)

Proof 1
Preservation of RC
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c defined. c[P↓] ⇓ᵢ b => b∈πₚ)

Satisfaction of closed properties
(∀b c defined. c[P↓] ⇓ᵢ b => b∈πₚ) => (∀b c. c[P↓] ⇓ᵢ b => b∈πₚ)

In general this is not true, for example if ub(t,C) ∉ πₚ the premise
is true but not the conclusion.
However if we apply some filtering or transformation in π it can be
satisfied:
- fix 1
π(b) = { b(t) | Π(t) }

- fix 2
πₚ(b) = { b(t) | filter(t,P) ∈ Π}

- fix 3
  use an alternative notion of property π(b)
TODO

*** HR notes
HR is necessary for the refinements of C and it's the reason it makes
sense to do DECR.

HR: ∀C. C[P]⇓b(t) => ∃C' defined. C'[P]⇓b'(t) /\ b'≠ub(t,C')     (most general)
    ∀C. C[P]⇓ub(t,C) => ∃C' defined. C'[P]⇓term(t,C')            (most specific)

Other versions:
    ∀C. C[P]⇓b(t) /\ b∈π => ∃C' defined. C'[P]⇓b(t) /\ db∈π
    ∀C. C[P]⇓b => ∃C' defined. C'[P]⇓b' /\ filter(b)=filter(b')
    ∀C. C[P]⇓b /\ b∈π => ∃C' FD. C'[P]⇓b' /\ b'≥b /\ b'∈π

TODO HR Proof
looks like a DECR and DEF at the same level
I could use DECR but I'd like to have a b' which is not longer that b,
ideally I can make a C' that instead of doing ub, as soon as it is
called terminates. This leads to the same filtering for b.
TODO if you have RC_SI and RC_IT it looks like you get HR, is it
related to compositionality?


SCL is necessary for the refinements of P
SCL: A property π is suffix closed or refDef closed iff
     ∀ ub(t,P) ∈π => refDef(ub(t,P)) ∈π

TODO: does SCL imply HR ??

** VDEF and RC
   RCD: ∀c defined. c[P↓] ⇓ₜ db => ∃C. C[P] ⇓ₛ db \/ (C[P] ⇓ₛ ub(pref(db),P) /\ ∃P'. C[P'] ⇓ₛ db)
   
   is this necessary to restrict refinements to DEF?
   It looks like it could be obtained from two rounds of RC.

** proof RC implies CCR - TODO

THIS SEEMS TO NEED RC FOR ALL SUBSETS

Proof.
n-DEC for all Pᵢ↓
PCCRD for all Pᵢ↓
n-COMP to obtain the shortest prefix of all ub(pref(b),Pᵢ)


C↓P↓ ⇓b => CP ⇓b ‌\/ CP ⇓ub(pref(b),C) \/ CP ⇓ub(pref(b),p) 



RC4(P, cs, db) = ∃Cs. ⋈(Cs,P) ⇓ₛ db \/ ⋈(Cs,P) ⇓ₛ ub(pref(db),P)
H1: ∀Pᵢ. RC4(Pᵢ, (P\Pᵢ)↓, db)
H2: ∀ b. P↓ ⇓ db
GOAL: P ⇓ db ∨ P ⇓ ub(prefix(db),Pᵢ)


H2=⋈(P₁,...,Pₙ)↓ ⇓ₜ db =>SC
⋈(P₁↓,...,Pₙ↓) ⇓ₜ db =>H1
∃Csᵢ.
(1) ⋈(Csᵢ,Pᵢ) ⇓ₛ db ‌\/
(2) ⋈(Csᵢ,Pᵢ) ⇓ₛ ub(pref(db),Pᵢ)

⋈(Csᵢ, Pᵢ)↓ ⇓ db'

Suppose ↓ is wrong, then either:
1) ⋈(Csᵢ, Pᵢ) ⇓ db
   db'  ≠ db
2) ⋈(Csᵢ, Pᵢ) ⇓ ub(t, Pᵢ)
   ¬∃ prefix(db') = t

(∀Pᵢ. ∃Csᵢ. ⋈(Csᵢ,Pᵢ) ⇓ₛ db 
* removing ub from properties
** changing satisfaction
A property π is a set of defined behaviors, π ⊆ DEF, where DEF
contains all the possible defined behaviors that a set of interfaces
can produce.

When a semantics produces an ub we need to expand it and check that
all its possible continuations are in π.

CCR:
   ∀ b. P↓ ⇓ᵢ b => P ⇓ₛ b ∨ P ⇓ₛ ub(prefix(b))

VDEF:
   ∀ p b. p ⇓ᵢ b => ∃ P. P ⇓ₛ b

CCRD:
   ∀ b. P↓ ⇓ᵢ b => P ⇓ₛ b
                ∨ (P ⇓ₛ ub(prefix(b)) ∧ ∃ P'. P' ⇓ₛ b)

Def: Whole program Satisfaction
WP satisfies π iff
∀t. WP ⇓ b =>
  (b=db => db ∈ π) ∧
  (b=ub(t) => ∀t'. t'≥t ∧ ∃WP'. WP' ⇓ db(t') => db(t') ∈ π)

Def: Preservation of WS
∀WP π. WP satisfies π => WP↓ satisfies π

Conjecture: CCDR <=> PWS

Th: CCRD => PWS
Proof
=>
Assume
  h1: WP↓ ⇓ᵢ b
  h2: CCRD
  h3: WP satisfies π
To show
  WP↓ satisfies π

  by h1, case analysis on b

  (* common case *)
  – b = db(t) for some t
    by CCRD
    1) WP ⇓ₛ db(t)
      to show db(t) ∈ π
      by h3, db ∈ π
    2) WP ⇓ₛ ub(prefix(t)) ∧ ∃ P'. P' ⇓ₛ db(t)
      to show db(t) ∈ π
      by h3, ∀t'. t'≥prefix(t) ∧ ∃WP'. WP' ⇓ₛ db(t') => db(t') ∈ π
      instantiate t' with t, then
        t≥prefix(t) ∧ ∃WP'. WP' ⇓ₛ db(t) => db(t) ∈ π
      but we know that ∃ P'. P' ⇓ₛ db(t), therefore db(t) ∈ π

  (* additional intermediate case *)
  – b = ub(t) for some t
    by CCRD
    1) WP ⇓ₛ ub(t)
      to show ∀t'. t'≥t ∧ ∃wp'. wp' ⇓ᵢ db(t') => db(t') ∈ π
      by h3, ∀t'. t'≥t ∧ ∃WP'. WP' ⇓ₛ db(t') => db(t') ∈ π
      STUCK
    2) WP ⇓ₛ ub(prefix(t)) ∧ ∃ P'. P' ⇓ₛ ub(t)
      to show ∀t'. t'≥t ∧ ∃wp'. wp' ⇓ᵢ db(t') => db(t') ∈ π
      by h3, ∀t'. t'≥prefix(t) ∧ ∃WP'. WP' ⇓ₛ db(t') => db(t') ∈ π
      STUCK

Th: PWS => CCRD
Proof
=>
  Assume
    h1: WP satisfies π => WP↓ satisfies π
    h2: WP↓ ⇓ᵢ b
  To show
    WP ⇓ₛ b ∨ (WP ⇓ₛ ub(prefix(b)) ∧ ∃ P'. P' ⇓ₛ b)

  We build a property π such that WP satisfies it:
    π = { db(t) | ∃ t. WP ⇓ₛ db(t) } ∪
        { db(t) | ∃ t t' P'. t≥t' ∧ WP ⇓ₛ ub(t') ∧ P' ⇓ₛ db(t) }
  We can see that WP satisfies π:
  – WP ⇓ₛ db(t) => db(t)
    by first construction set
  – WP ⇓ₛ ub(t) => ∀t'. t'≥t ∧ ∃WP'. WP' ⇓ db(t') => db(t') ∈ π
    by second construction set

  Since WP satisfies π, by PWS we have that WP↓ satisfies π.

  by case analysis on the behavior of the compiled program

  (* common case *)
  – b = db(t) for some t
    by satisfaction of π at the target, we have db(t) ∈ π
    by construction of π, either 1) or 2) holds
    1) WP ⇓ₛ db(t)
       the first disjunct is true, done
    2) ∃ t' P'. t≥t' ∧ WP ⇓ₛ ub(t') ∧ P' ⇓ₛ db(t)
       the second disjunct is true, since for some t' prefix of t
         WP ⇓ₛ ub(t'=prefix(t)) ∧ ∃ P'. P' ⇓ₛ db(t)

  (* additional intermediate case *)
  – b = ub(t) for some t
    by satisfaction of π at the intermediate, we have
      ∀t'. t'≥t ∧ ∃P'. P' ⇓ᵢ db(t') => db(t') ∈ π
    consider all such traces t' for which db(t') ∈ π
    by construction of π, either 1) or 2) holds
    1) WP ⇓ₛ db(t')
       WP ⇓ₛ ub(t') and WP↓ ⇓ᵢ ub(prefix(t'))
       weird case, the source behavior is more defined than the intermediate one
       STUCK this shouldn't probably happen
    2) ∃ t'' P'. t'≥t'' ∧ WP ⇓ₛ ub(t'') ∧ P' ⇓ₛ db(t')
       we have to consider the relation between t and t''
       we know that t and t'' are prefixes of t', therefore they share a common
       prefix. Three cases:
       — t ≤ t'', t is a prefix of t''
         WP ⇓ₛ ub(t'') and WP↓ ⇓ᵢ ub(prefix(t''))
         weird case, the source behavior is more defined than the intermediate one
         STUCK this shouldn't probably happen
       – t = t'', same prefix
         WP ⇓ₛ ub(t) and WP↓ ⇓ᵢ ub(t)
         pick the first disjunct, done
       – t ≥ t'', t'' is a prefix of t
         WP ⇓ₛ ub(prefix(t)) and WP↓ ⇓ᵢ ub(t)
         moreover ∃ P'. P' ⇓ₛ db(t')
         pick the second disjunct, the first conjunct is satisfied
         we must show the second conjunct, ∃ P'. P' ⇓ₛ ub(t)
         STUCK we don't have enough information to prove this fact

Th: CCR+VDEF => PWS
Proof
=>
Assume
  h1: WP↓ ⇓ᵢ b
  h2: CCR+VDEF
  h3: WP satisfies π
To show
  WP↓ satisfies π

  by h1, case analysis on b
  – b = db(t) for some t
    by CCR
    1) WP ⇓ₛ db(t)
      to show db(t) ∈ π
      by h3, db ∈ π
    2) WP ⇓ₛ ub(prefix(t))
      to show db(t) ∈ π
      by h3, ∀t'. t'≥prefix(t) ∧ ∃WP'. WP' ⇓ₛ db(t') => db(t') ∈ π
      instantiate t' with t, then
        t≥prefix(t) ∧ ∃WP'. WP' ⇓ₛ db(t) => db(t) ∈ π
      by VDEF on WP↓ and db(t), we have ∃ WP'. WP' ⇓ₛ db(t)
      but then db(t) ∈ π
  – b = ub(t) for some t
    by CCR
    1) WP ⇓ₛ ub(t)
      to show ∀t'. t'≥t ∧ ∃wp'. wp' ⇓ᵢ db(t') => db(t') ∈ π
      by h3, ∀t'. t'≥t ∧ ∃WP'. WP' ⇓ₛ db(t') => db(t') ∈ π
      by VDEF on wp' and db(t'), we have t'≥t ∧ ∃ WP'. WP' ⇓ₛ db(t')
      but then db(t') ∈ π
    2) WP ⇓ₛ ub(prefix(t))
      to show ∀t'. t'≥t ∧ ∃wp'. wp' ⇓ᵢ db(t') => db(t') ∈ π
      by h3, ∀t'. t'≥prefix(t) ∧ ∃WP'. WP' ⇓ₛ db(t') => db(t') ∈ π
      by VDEF on wp' and db(t'), we have t'≥t (because t'≥prefix(t)) ∧ ∃ WP'. WP' ⇓ₛ db(t')
      but then db(t') ∈ π

Alternative attempt with CCR+VDEF, still half broken

Th: PWS => CCR+VDEF
Proof
=>
Assume
  h1: WP satisfies π => WP↓ satisfies π
To show
  CCR ∧ VDEF

1) CCR
   IDEA if the compiler is incorrect, there must exist a program for which at
        least behavior is not preserved. We start from this program and
        behavior and build a property π that doesn't include such miscompilation.

   For any given program P, we can build a property π as
     π = { db(t) | ∃ t. P ⇓ₛ db(t) } ∪
         { db(t) | ∃ P' t t'. t≥t' ∧ P ⇓ₛ ub(t') ∧ P' ⇓ₛ db(t) }

   Notice that P satisfies π (TODO need more details here)

   Now suppose that the compiler is incorrect, then there exists a program P
   for which at least one of its behaviors is not preserved.
   Pick such program P and bad behavior bbad, then build π with the method above.

   In particular we need a bbad such that it cannot be produced by the original
   program (TODO think more, need some details here)
     P↓ ⇓ᵢ bbad(t) ∧ ¬ P ⇓ₛ db(t) ∧ ¬ P ⇓ₛ ub(t)

   Intuition:
     by construction, bbad ∉ π (because it cannot be produced by P at the source)
     but by h1 and π satisfaction, we know that bbad ∈ π
     we assumed the compiler to be incorrect, but we arrived at a contradiction.
     therefore, the compiler must be correct.

   Since bbad is bad, ¬ P ⇓ₛ ub(t) ∧ ¬ P ⇓ db(t)
   Case analysis on bbad
   – bbad = db(t) for some t
     by h1, db(t) ∈ π (contra)
   – bbad = ub(t) for some t
     by h1, ∀ t'. t'≥t ∧ ∃ P'. P' ⇓ᵢ db(t') => db(t') ∈ π
     pick t'=t, then db(t) ∈ π
     but we know that db(t) ∉ π (contra)

2) VDEF
   to show ∀ p b. p ⇓ᵢ b => ∃ P'. P ⇓ₛ b

   NOTE: Not sure if we can prove VDEF from PWS.
         VDEF starts with an arbitrary low level program, but PWS only talks
         about compiled programs.

   — Proof sketch for compiled programs

   IDEA π must contain only source-level defined behavior
        db(t) ∈ π => ∃ P. P ⇓ₛ db(t)
        if π is preserved, it means we can oberve only source-level behaviors
        at all levels

   For any given program P, we can build a property π as
     π = { db(t) | ∃ t. P ⇓ₛ db(t) } ∪
         { db(t) | ∃ P' t t'. t≥t' ∧ P ⇓ₛ ub(t') ∧ P' ⇓ₛ db(t) }

   Notice that P satisfies π (TODO need more details here)

   We show that given P↓ ⇓ᵢ b, there exists P' such that P' ⇓ₛ b
   Case analysis on b
   – b = db(t) for some t
     by h1, db(t) ∈ π
     therefore, by construction of π, either P ⇓ₛ db(t) or ∃ P'. P' ⇓ₛ db(t)
   – b = ub(t) for some t
     by h1, ∀ t'. t'≥t ∧ ∃ P'. P' ⇓ᵢ db(t') => db(t') ∈ π
     pick t'=t, then either exists P' such that P' ⇓ᵢ db(t) or it doesn't exist.
     1) P' exists
        but then db(t) ∈ π, which proves our goal as in the previous case
     2) P' doesn't exist
        this case should be impossible. The intuition is that since we have
        observed ub(t) with P↓, there must exist a program P' such that it does
        the very same trace t and then it either terminates or diverges silently
        instead of having undefined behavior. (TODO need more details here)


Def: Robust Satisfaction 123
P robustly satisfies π iff
∀C t. C[P] ⇓ b =>
  (b=db => db ∈ π) ∧
  (b=ub(t,P) => ∀t'. t'≥t ∧ ∃WP. WP ⇓ db(t') => db(t') ∈ π) ∧
  (b=ub(t,C) => ∀t'. t'≥t ∧ ∃C'. C'[P] ⇓ db(t') => db(t') ∈ π)

Def: Robust Satisfaction 12
∀C t. C[P] ⇓ b ∧ b≠ub(t,C) =>
  (b=db => db ∈ π) ∧
  (b=ub(t,P) => ∀t'. t'≥t ∧ ∃WP. WP ⇓ db(t') => db(t') ∈ π)


Th: RS12 <=> RS123
Proof
– => part
  We want to show that
   ∀C t. C[P] ⇓ b =>
     (b=db => db ∈ π) ∧
     (b=ub(t,P) => ∀t'. t'≥t ∧ ∃WP. WP ⇓ db(t') => db(t') ∈ π) ∧
     (b=ub(t,C) => ∀t'. t'≥t ∧ ∃C'. C'[P] ⇓ db(t') => db(t') ∈ π)
  Pick C such that C[P] ⇓ b.
  Case analysis on b:
  1) b=db(t) ∨ b=ub(t,P)
    Since b≠ub(t,C), we can directly apply RS12.
  2) b=ub(t,C)
    We cannot apply RS12, since we have an undefined behavior because of C.
    The first two cases trivially holds, therefore we focus just on the third
    case. We want to show that ∀t'. t'≥t ∧ ∃C'. C'[P] ⇓ db(t') => db(t') ∈ π
    That is, given C' and t' such that t'≥t ∧ C'[P] ⇓ db(t'), we show db(t') ∈ π
    Since C'[P] ⇓ db(t'), we can apply RS12 and obtain db(t') ∈ π, our goal.
– <= part
  This is the trivial part, since we just have to map one-to-one our facts.
  We want to show that:
  ∀C t. C[P] ⇓ b ∧ b≠ub(t,C) =>
    (b=db => db ∈ π) ∧
    (b=ub(t,P) => ∀t'. t'≥t ∧ ∃WP. WP ⇓ db(t') => db(t') ∈ π)
  Pick C such that C[P] ⇓ b ∧ b≠ub(t,C)
  Now, either b=db(t) or b=ub(t,P).
  In both cases we can apply RS123 and show that
    (b=db => db ∈ π) ∧
    (b=ub(t,P) => ∀t'. t'≥t ∧ ∃WP. WP ⇓ db(t') => db(t') ∈ π)

Def: Robust Compilation
RC: ∀c t. c[P↓] ⇓ᵢ b(t) ∧ b(t)≠ub(t,C) => ∃C. C[P] ⇓ₛ b(t) ∨ C[P] ⇓ₛ ub(pref(t),P)

Def: Preservation of Robust Satisfaction
∀P π. P robustly satisfies π => P↓ robustly satisfies π

Th: RC <=> PRS
TODO

** changing notion of robust satisfaction
Proof and definition become more detailed, which means clearer but also harder to read.
The π contains only DEF and it's much clearer.

*** Robust Satisfaction:
   P robustly satisfies π ⊆ DEF
   ∀P t C. C[P]⇓b(t) =>
   (b=db(t) => db(t) ∈ π) /\
   (b=ub(t,Pᵢ) => ∀t'. t≤t' /\ ∃P'. C[P'] ⇓ db(t') /\ db(t') ∈ π
   (b=ub(t,C) => ∀t'. t≤t' /\ ∃P'. C[P'] ⇓ db(t') /\ db(t') ∈ π

   (b=ub(t,C) => ∃db. db(t) ∈ π) /\
   (b=ub(t,C) => ∃db. db(t') ∈ π /\ t≤t') /\
   (b=ub(t,C) => ∀db. db(t') ∈ π /\ t≤t') /\

   Note that satisfaction for whole programs is an instance with an
   empty C and the second match doesn't occur.

*** Preservation of RS:
    RS_L1(P) => RS_L2(P↓)
*** RC+HR => PRS_SI

Assume
  HR: ∀C. C[P]⇓b(t) => ∃C' defined. C'[P]⇓b'(t) /\ b'≠ub(t,C')

Assume h1 
  ∀P tₛ C. C[P]⇓ₛ b(tₛ) =>
  (b(tₛ)=db(t) => db(tₛ) ∈ π) /\
  (b(tₛ)=ub(tₛ,C) => ∃db(tₛ') ∈ π /\ tₛ≤tₛ') /\
  (b(tₛ)=ub(tₛ,P) => ∀tₛ'. tₛ≤tₛ' /\ db(tₛ') ∈ π)

Assume h2
  ∀P tᵢ c. c[P↓]⇓ᵢb(tᵢ)

Goal
  (b(tᵢ)=db(tᵢ) => db(tᵢ) ∈ π) /\
  (b(tᵢ)=ub(tᵢ,c) => ∃db(tᵢ') ∈ π /\ tᵢ≤tᵢ') /\
  (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)


i) c no ub, P↓ no ub, P ref/no ref
h2: c[P↓]⇓ᵢdb(tᵢ) =>RC4
∃C. C[P] ⇓ₛ b(tᵢ)
1) C[P] ⇓ₛ db(tᵢ)
by RS db(tᵢ) ∈ π
2) C[P] ⇓ₛ ub(prefix(tᵢ), P)
To show
    (b(tᵢ)=ub(tᵢ,P↓) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)
by RS ∀tᵢ'. prefix(tᵢ)≤tᵢ' /\ db(tᵢ') ∈ π

ii) c no ub, P↓ ub, P ref/no ref
h2: c[P↓]⇓ᵢub(tᵢ,P) =>RC4
∃C.
1) C[P] ⇓ₛ ub(tᵢ,P)
To show:
  (b=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)
by RS: ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π
2) C[P] ⇓ₛ ub(prefix(tᵢ), P)
To show:
  (b=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)
by RS ub(prefix(tᵢ),P) => ∀ tᵢ'. prefix(tᵢ)≤tᵢ' /\ db(tᵢ') ∈ π

iii) c ub, P↓ no ub, P ref/no ref
h2: c[P↓]⇓ᵢub(tᵢ,C) =>HR
∃b' c' defined. c'[P↓]⇓ᵢb'(tᵢ) /\ b'≠ub(tᵢ,c') =>RC4
by i) or ii)

*** RC => PRS_IT
    is a special case of the previous proof
*** RC_SI + RC_IT => RC_ST
    interesting?
*** PSR_SI + PSR_IT => PSR_ST
Assume PRS_SI
  (∀P tₛ C. C[P]⇓ₛ b(tₛ) =>
   (b(tₛ)=db(t) => db(tₛ) ∈ π) /\
   (b(tₛ)=ub(tₛ,C) => ∃db(tₛ') ∈ π /\ tₛ≤tₛ') /\
   (b(tₛ)=ub(tₛ,P) => ∀tₛ'. tₛ≤tₛ' /\ db(tₛ') ∈ π)) =>
  (∀P tᵢ C. C[P↓]⇓ᵢ b(tᵢ) =>
   (b(tᵢ)=db(t) => db(tᵢ) ∈ π) /\
   (b(tᵢ)=ub(tᵢ,C) => ∃db(tᵢ') ∈ π /\ tᵢ≤tᵢ') /\
   (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π))

Assume PRS_IT
  (∀P tᵢ C. C[P]⇓ᵢ b(tᵢ) =>
   (b(tᵢ)=db(t) => db(tᵢ) ∈ π) /\
   (b(tᵢ)=ub(tᵢ,C) => ∃db(tᵢ') ∈ π /\ tᵢ≤tᵢ') /\
   (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)) =>
  (∀P tₜ C. C[P↓]⇓ₜ b(tₜ) =>
   (b(tₜ)=db(t) => db(tₜ) ∈ π) /\
   (b(tₜ)=ub(tₜ,C) => ∃db(tₜ') ∈ π /\ tₜ≤tₜ') /\
   (b(tₜ)=ub(tₜ,P) => ∀tₜ'. tₜ≤tₜ' /\ db(tₜ') ∈ π))

Assume
  (∀P tₛ C. C[P]⇓ₛ b(tₛ) =>
   (b(tₛ)=db(t) => db(tₛ) ∈ π) /\
   (b(tₛ)=ub(tₛ,C) => ∃db(tₛ') ∈ π /\ tₛ≤tₛ') /\
   (b(tₛ)=ub(tₛ,P) => ∀tₛ'. tₛ≤tₛ' /\ db(tₛ') ∈ π))

To show
  (∀P tₜ C. C[P↓↓]⇓ₜ b(tₜ) =>
   (b(tₜ)=db(t) => db(tₜ) ∈ π) /\
   (b(tₜ)=ub(tₜ,C) => ∃db(tₜ') ∈ π /\ tₜ≤tₜ') /\
   (b(tₜ)=ub(tₜ,P) => ∀tₜ'. tₜ≤tₜ' /\ db(tₜ') ∈ π))

* Robust Execution (variant of NEW_RC_DC)
What we would like to have is something finer-grained that, ideally, replaces
only those components which cause problems.

RE (Robust Execution):
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
Notes:
  – ρ is a low level program
  – compiler correctness seems to be not required
  – NEW_RC_DC can be obtained by instantiating ρ with both compiled (P) and
    arbitrary (C) components and then looking just at the backmapping of C
  – this property is more general, since it works for arbitrary low level
    components. My intuition is that our environment of execution guarantees the
    backmapping argument for every component, no matter where it comes from
    (e.g. compiled or hand-written).

[CH: not sure about the "more general" part, NEW_RC_DC was stated for
     arbitrary programs and contexts, which is already more general
     than the sets of components model.]
[CH: also, I don't see the fact that this property is n-ary as a plus,
     on the contrary, it seems like a pain]
[CH: finally, could it be that NEW_RC_DC => RE direction also holds?
     I simply take pᵢ to be c and ρ\pᵢ to be P.]

Lemma:
  RE => NEW_RC_DC
Proof:
  Given an arbitrary low level component c and a source level component P, we
  want to show that
    c[P↓] ⇓ b  ⇒  ∃C. FD(C) ∧ C↓[P↓] ⇓ b
  That is, we observed c[P↓] ⇓ b and we need to exhibit a source level component
  C such that
    C fully defined ∧ C↓[P↓] ⇓ b
  by RE instantiated with c and P↓, we can pick the case in which we backmap c
    ∃ C. FD(C) ∧ C↓[P↓] ⇓ b

  [CH: In the NEW_RC_DC instance for components I would expect both c
       and P to be *sets* of components. ]

Lemma:
  CCR ∧ RE => RC4
Proof:
  should follow from multiple applications of RE and then CCR

** Preservation of Robust Satisfaction by means of CCR and RE

[CH: Isn't this just a consequence of:
  (0) RE => NEW_RC_DC
  (1) NEW_RC_DC + CCR => OLD_RC_DC (super simple)
  (2) OLD_RC_DC => PRS (super simple too, counterpositive) ]

Main Theorem:
  CCR ∧ RE => PRS
Notes:
  if we prove that our compiler is correct (CCR) and that our execution
  environment is robust (RE), then it means that robust satisfaction is
  preserved no matter what other components do (e.g. undefined behavior)
Proof:
  Given a source level component P and a property Πₚ, we want to show PRS:
  We know that RS holds at the source level
    ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
           (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P))).
  Given arbitrary c (sets of low level components) and b such that ⋈(c, P↓) ⇓ b,
  we have to show that Πₚ(filter(b, P))

  by RE instantiated with cᵢ ∈ c and P↓, we can pick the case in which we backmap cᵢ
    ∃ Cᵢ. FD(Cᵢ) ∧ ⋈(c\cᵢ, Cᵢ↓, P↓) ⇓ b
  we can do this last thing repeatedly for all the cᵢ ∈ c, until we have all Cᵢ such
  that ∀ i. FD(Cᵢ) ∧ ⋈(C₁↓, ..., Cₙ↓, P↓) ⇓ b
  For brevity, C = {C₁, ..., Cₙ}
  by Separate Compilation
    ⋈(C, P)↓ ⇓ b
  by CCR, three cases
    1) ⋈(C, P) ⇓ b
       by RS at the source we have Πₚ(filter(trace(b), P)), our goal
    2) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, C)
       This cannot happen, since ∀ i. FD(Cᵢ)
    3) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, P)
       by RS at the source we have ∀ ref. Πₚ(filter(pref;ref, P))
       we can destruct trace(b) as trace(b)=pref;t
       then we can instantiate ref with t and obtain Πₚ(filter(pref;t), P)
       this means Πₚ(filter(trace(b), P)), our goal
** Our Instance
Proving RE in our context requires different ingredients:
  1) Partial Semantics
  1) Decomposition:
     A whole program can be simulated by the very same program without some
     components in the partial semantics.
  2) Composition:
     Two compatible partial programs that have the same behavior in
     the partial semantics can be simulated in the complete semantics by a whole
     program obtained by merging them.
  3) Component Definability:
     Given a behavior observed at the low level, we can exhibit a fully defined
     source component which exactly reproduces it.
  4) Forward Compiler Correctness for partial programs:
     The compiler preserves the program semantics when we are in the partial
     semantics.

Decomposition and Composition are simulations which should be provable.

Compiler Correctness for partial programs should follow from CCR.

Definability is definitely the most difficult one. For finite traces we should
be able to prove it, but for the infinite ones we have no clue about how to
proceed. A possibility could be to give guarantees on all the finite traces that
are prefix of an infinite behavior.

*** Proof
We want to show that
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
That is, we have ρ such that ⋈(ρ) ⇓ b and we want to show
  ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
We show the above fact for an arbitrary pᵢ ∈ ρ.
by Decomposition
  pᵢ ⇓{p\pᵢ} b
by Definability
  ∃ Pᵢ. FD(Pᵢ) ∧ Pᵢ ⇓{ρ\pᵢ} b
by Forward Compiler Correctness for partial programs
  Pᵢ↓ ⇓{ρ\pᵢ} b
by Decomposition
  ⋈(p\pᵢ) ⇓{pᵢ} b
by Composition
  ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
we have that
  ∃ Pᵢ FD(Pᵢ) ∧ ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
  which is what we wanted to show.
** Robust Execution with Undefined Behavior at target
RE (Robust Execution):
  ∀ ρ={p₁,...,pₙ}.
    (⋈(ρ) ⇓ b =>
      ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b) ∨
    (⋈(ρ) ⇓ GoingWrong(t, pᵢ) =>
      (∀ pⱼ s.t. j ≠ i. ∃ Pⱼ. FD(Pⱼ) ∧ ⋈(ρ\pⱼ ∪ Pⱼ↓) ⇓ GoingWrong(t, pᵢ)) ∧
      (∃ Pᵢ b'. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b' ∧ trace(b') = t)
* Mutual Distrust for πᵢ (broken variant of RC_DC+MD?)
An interesting case is the one with more than two mutually distrustful source
level components. There are several characterization of it, the iterative one
being the most promising.

RC4(P, cs, db) = ∃Cs. ⋈(Cs,P) ⇓ₛ db \/ ⋈(Cs,P) ⇓ₛ ub(pref(db),P)

MD:
P = {P₁, ..., Pₙ}
⋈(P)↓ ⇓ b => ∀ Pᵢ. RC4(Pᵢ, (P\Pᵢ)↓, b)

[CH: I don't see any iteration here, RC4 is not recursive!?]

* Mutual Distrust for π (related to less iterative variants RC_DC+MD' and RC_DC+MD''?)

RC4(Ps, cs, db) = ∃Cs. ⋈(Cs,Ps) ⇓ₛ db \/ ∃Pᵢ. ⋈(Cs,Ps) ⇓ₛ ub(pref(db),Pᵢ)

MD:
P = {P₁, ..., Pₙ}   Ps ∈ subsets(P)
⋈(P)↓ ⇓ b => ∀ Ps. RC4(Ps, (P\Ps)↓, b)
  
* Bits and pieces
** De/composition with refinement
If we want to have UB in a language then we need to add refinement to its decomposition.
If the context does UB then the partial context refines it.
DECR: ∀C. C[P] ⇓ b => P ⇓{C} b' /\ (b'=b ‌\/ b=pref(b');UB(C))       (note that P can do UB, there is no refinement for P)

Simmetrically we defined composition with a refinement:
COMPR: C ⇓{P} b /\ P ⇓{C} b => C[P] ⇓ b \/ C[P] ⇓ pref(b);UB
TODO CHECK ALL UB CASES

Definability on the same level (the old definability):
DEFS: P ⇓{C} b => ∃C. C[P] ⇓ b      (on the Same level. P can do UB and C cannot)
** Partial Definability
PDEF: PP ⇓ₜ b  => ∃PP'. PP'⇓ₛ b
PDEF on all components implies DEF on whole programs: WP ⇓ₜ b  =>? ∃WP'. WP'⇓ₛ b
WP ⇓ₜ b => ⋈(p₁,...,pₙ) ⇓ₜ b 
       =>DEC ∀pᵢ. pᵢ ⇓pt b 
       =>PDef ∀pᵢ. ∃Pᵢ'. Pᵢ' ⇓ps b 
       =>COMP ⋈(P₁',...,Pₙ') ⇓ₛ b 
       => WP'⇓ₛ b
TODO: If there is UB in b (e.g. if we are at intermediate instead of
target) then we need to use DECR and recheck the proof

** Preservation of Robust Satisfaction by means of CCR and RE
Main Theorem:
  CCR ∧ RE => PRS
Notes:
  if we prove that our compiler is correct (CCR) and that our execution
  environment is robust (RE), then it means that robust satisfaction is
  preserved no matter what other components do (e.g. undefined behavior)
Proof:
  Given a source level component P and a property Πₚ, we want to show PRS:
  We know that RS holds at the source level
    ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
           (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P))).
  Given arbitrary c (sets of low level components) and b such that ⋈(c, P↓) ⇓ b,
  we have to show that Πₚ(filter(b, P))

  by RE instantiated with cᵢ ∈ c and P↓, we can pick the case in which we backmap cᵢ
    ∃ Cᵢ. FD(Cᵢ) ∧ ⋈(c\cᵢ, Cᵢ↓, P↓) ⇓ b
  we can do this last thing repeatedly for all the cᵢ ∈ c, until we have all Cᵢ such
  that ∀ i. FD(Cᵢ) ∧ ⋈(C₁↓, ..., Cₙ↓, P↓) ⇓ b
  For brevity, C = {C₁, ..., Cₙ}
  by Separate Compilation
    ⋈(C, P)↓ ⇓ b
  by CCR, three cases
    1) ⋈(C, P) ⇓ b
       by RS at the source we have Πₚ(filter(trace(b), P)), our goal
    2) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, C)
       This cannot happen, since ∀ i. FD(Cᵢ)
    3) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, P)
       by RS at the source we have ∀ ref. Πₚ(filter(pref;ref, P))
       we can destruct trace(b) as trace(b)=pref;t
       then we can instantiate ref with t and obtain Πₚ(filter(pref;t), P)
       this means Πₚ(filter(trace(b), P)), our goal
** Our Instance
Proving RE in our context requires different ingredients:
  1) Partial Semantics
  1) Decomposition:
     A whole program can be simulated by the very same program without some
     components in the partial semantics.
  2) Composition:
     Two compatible partial programs that have the same behavior in
     the partial semantics can be simulated in the complete semantics by a whole
     program obtained by merging them.
  3) Component Definability:
     Given a behavior observed at the low level, we can exhibit a fully defined
     source component which exactly reproduces it.
  4) Forward Compiler Correctness for partial programs:
     The compiler preserves the program semantics when we are in the partial
     semantics.

Decomposition and Composition are simulations which should be provable.

Compiler Correctness for partial programs should follow from CCR.

Definability is definitely the most difficult one. For finite traces we should
be able to prove it, but for the infinite ones we have no clue about how to
proceed. A possibility could be to give guarantees on all the finite traces that
are prefix of an infinite behavior.

*** Proof
We want to show that
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
That is, we have ρ such that ⋈(ρ) ⇓ b and we want to show
  ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
We show the above fact for an arbitrary pᵢ ∈ ρ.
by Decomposition
  pᵢ ⇓{p\pᵢ} b
by Definability
  ∃ Pᵢ. FD(Pᵢ) ∧ Pᵢ ⇓{ρ\pᵢ} b
by Forward Compiler Correctness for partial programs
  Pᵢ↓ ⇓{ρ\pᵢ} b
by Decomposition
  ⋈(p\pᵢ) ⇓{pᵢ} b
by Composition
  ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
we have that
  ∃ Pᵢ FD(Pᵢ) ∧ ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
which is what we wanted to show.
** Catalin's example Guglielmo
Now that we have the main ingredients for talking about security, we can see
why CCR and CCRD are not enough to allow this kind of preservation:

  Consider TC and UC as, respectively, trusted and untrusted source level components.

  TC is verified, meaning that it is fully defined, FD(TC), and it robusty
  satisfies a property Πₜ.

  UC is not verified, thus it could exhibit undefined behavior at any point
  during its execution.

  Claim:
    CCRD doesn't guarantee PRS
  Proof:
    Let's suppose to have observed ¬Πₜ(filter(trace(b_bad),P)) at the low level after having
    compiled down TC and UC.
      ⋈(TC↓, UC↓) ⇓ b_bad
    by Separate Compilation
      ⋈(TC, UC)↓ ⇓ b_bad
    by CCRD, two cases
      1) ⋈(TC, UC) ⇓ b_bad
         by Robust Satisfaction
           ⋈(TC, UC) ⇓ b_bad => Πₜ(filter(trace(b_bad), P))
         but we know that ¬Πₜ(filter(trace(b_bad), P)), hence this case cannot happen.
      2) ∃ pref ∈ prefixes(trace(b_bad)). ⋈(TC, UC) ⇓ GoingWrong(pref) ∧ ∃ P'. P' ⇓ b_bad
         Firstly, notice that the undefined behavior could have only happend
         because of UC, since FD(TC).
         by Robust Satisfaction
           ⋈(TC, UC) ⇓ GoingWrong(pref, C) =>
             Πₜ(filter(trace(GoingWrong(pref, C)), P) => Πₜ(filter(pref, P))
         therefore, it must be the case that Πₜ(filter(pref, P)) and the bad things
         characterizing b_bad happen after the undefined behavior at the source level.
         we have been able to observe a bad behavior of P at the low level, even
         if P was verified!
** Catalin's example Marco
Applying DEF and CCBR to the whole program is not enough to prevent a
bad behavior.
It is possible to have a bad behavior at the target if we use only
CCBR, as a result of a refinement:
⋈(Ctrusted, Cuntrusted)↓ ⇓ₜ b_bad =>CCBR
let P=⋈(Ctrusted, Cuntrusted) in P ⇓ₛ b \/ P ⇓ₛ pref(b);UB(Cuntrusted)
And that behavior can be picked up by definability.
⋈(Ctrusted, Cuntrusted)↓ ⇓ₜ b_bad ⇒ ∃P'. P' ⇓ₛ b_bad
The intuition is that an UB in any component makes the others lose
guarantees, even if they are f.d.

We need to apply a finer notion, PCCBR.
The intuition is that because we have correct compilation the
behaviors at target cannot be bad, so the example doesn't apply.
P FD and robustly satisfies π: ∀C. C[P] ⇓b => b ∈ π(P)
b_bad ∉ π(P)
C↓[P↓] ⇓ₜ b_bad
=>DEC P↓ ⇓ₜ{C} b_bad
=>PCCBR P ⇓ₛ{C} b_bad   (because P is verified we can do only one case)
=>DEFS ∃C'. C'[P] ⇓ₛ b_bad
This is a contradiction because P robustly satisfies π.

The same holds from intermediate with UB
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBR P ⇓ₛ{C} b' (because P is verified we can do only one case)
=>DEFS ∃C'. C'[P] ⇓ₛ b'
This should be a contradiction because if b_bad is not in π, the same
should hold for any of its refinements.



P unverified
C↓[P↓] ⇓ₜ b_bad
=>DEC P↓ ⇓ₜ{C} b_bad
=>PCCBR P ⇓ₛ{C} b_bad \/ P ⇓ₛ{C} pref(b_bad);UB(P) 
=>DEFS ∃C'. C'[P] ⇓ₛ pref(b_bad);UB(P)
we can guarantee up to the pref(b_bad).



What if P is not verified?
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBR P ⇓ₛ{C} b'' /\ (b''=b' \/ b''=pref(b');UB(P))
=>DEFS ∃C'. C'[P] ⇓ₛ ??
Is this a contradiction? What is the connection between b_bad and b''?


What if P is not verified and we use PCCBD?
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBD P ⇓ₛ{C} b' \/ (P ⇓ₛ{C} pref(b');UB(P) /\ ∃P'. P' ⇓ₛ{C} b)
left=>DEFS ∃C'. C'[P] ⇓ₛ b'??
right=>DEFS ∃C'. C'[P] ⇓ₛ b'??

Is this a contradiction? What is the connection between b_bad and b''?

** fully definedness
FD (Fully Definedness):
  ∀ C b. ¬ (⋈(C, P) ⇓ GoingWrong(b))
TODO in many cases we might need only definedness for a specific behavior b
** another variant

   Π ⊆ { db(t) | ∃ C. C[P] ⇓ db(t) } ∪ { db(t) | ∃ C. C[P] ⇓ ub(t,P) }

   πₚ = Π ∪ { db(t) | ∃C t'. C[P] ⇓ ub(t',P) /\ t'≤t /\ ∃P'. C[P'] ⇓ db(t) /\ ∃ db(t') ∈ Π) }
// (∃ t'. C[P] ⇓ ub(t',C) /\ t'≤t /\ ∃ db(t) ∈ Π) \/

   P is FD => πₚ = Π


   Π ⊆ { db(t)   | ∃ C. C[P] ⇓ db(t) } ∪
       { ub(t,P) | ∃ C. C[P] ⇓ ub(t,P) }

   πₚ = Π
      ∪ { ub(t',C) | ∃ t t'. t >= t' /\ db(t) ∈ Π }
      ∪ { db(t)    | ∃ t t'. t >= t' ‌/\ ub(t',P) ∈ Π }.

   P has UB with ε => { ε } ∈ Π /\ πₚ = { db(t) | ∃ C. ∃ P'. P' ⇓ db(t) }

   Robust Satisfaction:
     ∀P t C. C[P]⇓b(t) =>
       (b=db(t) => db(t) ∈ πₚ) /\
       (b=ub(t,_) => ∃ db(t) ∈ πₚ)
* complete proof for our instance and our targets
  we can use RC from c[P↓] to C[P] to obtain PRS_SI.
  if we use CC from (c[P↓])↓ to c[P↓] we get only PS_IT which in
  principle is not enough to preserve our properties.
  however below there is a proof that CC provides PRS_IT.
  maybe it works because we start from the target, we should try to
  prove PRS_SI from CC_SI, if it works then there is something very
  broken.
  TODO check where the proof should break


  To Show:
  PRS_IT:
  (∀P tᵢ c. c[P↓]⇓ᵢ b(tᵢ) =>
  (b(tᵢ)=db(tᵢ) => db(tᵢ) ∈ π) /\
  (b(tᵢ)=ub(tᵢ,C) => ∃db(t,t') ∈ π) /\           TODO I CHANGED THIS CASE!
  (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π))
  =>
  (∀P tₜ c. (c[P↓])↓ ⇓ₜ db(tₜ) => db(tₜ) ∈ π)

  Assume CC (WP=c[P↓]):
  ∀ b. (c[P↓])↓ ⇓ₜ db(tₜ) => c[P↓] ⇓ᵢ db(tₜ) ∨ c[P↓] ⇓ᵢ ub(prefix(tₜ))

  Assume h1:
  (∀P tᵢ c. c[P↓]⇓ᵢ b(tᵢ) =>
  (b(tᵢ)=db(tᵢ) => db(tᵢ) ∈ π) /\
  (b(tᵢ)=ub(tᵢ,C) => ∃db(tᵢ) ∈ π) /\
  (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π))

  Assume h2:
  ∀P tₜ c. (c[P↓])↓ ⇓ₜ db(tₜ)

  Proof:
  h2 =>CC
  i) c[P↓] ⇓ᵢ db(tₜ) ∨
  ii) c[P↓] ⇓ᵢ ub(prefix(tₜ))

  i) => h1
     db(tₜ) ∈ π OK

  ii.a) c[P↓] ⇓ᵢ ub(prefix(tₜ),P) =>h1
         ∀tᵢ'. prefix(tₜ)≤tᵢ' /\ db(tᵢ') ∈ π => specialize tᵢ'=tₜ
         db(tₜ) ∈ π OK

  ii.b) c[P↓] ⇓ᵢ ub(prefix(tₜ),C) =>h1
        ∃db(prefix(tₜ),t') ∈ π =>
        ∃c'. c'[P↓] ⇓ᵢ db(prefix(tₜ),t')
        db(tₜ)
        TODO how do we know that is the correct db? we could stenghten PRS with ∀db(t). db(t)∈π.


        Imagine a bad trace at the target db(t₁t₂) where t₁ respects
        πₚ and t₂ breaks it, we know that db(t₁t₂) ∉π. It is mapped by
        CC to a trace ub(t₁,C) which corresponds to a db(t₁) in πₚ.
        This doesn't seem to help, the only way to have t₁t₂ in π is
        to have them in a defined behavior db(t₁t₂), the only way to
        backmap a defined behavior is to do it precisely.

        TODO is CC with components a special case of RC?
* catalin's example to separate RC_DC with RC_SC
  Cₜ is a component that never 'blows_up' unless it has 'ask'ed the user and got back 'yes'. 
     it is semi-trusted, it has undefined behavior only if returned a 'bad' input after calling Cᵤ.P
  Cᵤ is untrusted and can return a bad input to Cₜ

  the property that we want to preserve is that an event blow_up can
  only happen if it follows a yes or an bad input.

  π = { b(t) | t=t₁:blow_up:t₂ => [Cₜ Call ask :: Ret yes] ∈ t₁ ‌\/
                                  [Cₜ Call Cᵤ.P :: Ret bad] ∈ t₁ }

  old_rc_dc seems to save this example

  TODO finish writing
