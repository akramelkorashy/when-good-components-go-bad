* Behaviors and events
** Events and traces
Let's assume that there is a hierarchy of expressiveness on our
languages, such that the each language is less expressive than the
language it is compiled to. We define for each language a set of
events Σ, where for our instance Σₛ ⊆ Σᵢ ⊆ Σₜ.
We also use the notation t for a trace of events (finite or infinite).

** Behaviors
behaviors are constructors over traces that we split in defined
and undefined. Note here is left implicit that div is the only one
that can have an infinite trace.

db := term(t) | div(t)
b := defined | ub(t)

** Whole Program
DEF   = { db(t) | ∃P. P⇓db(t) }                    Defined programs behaviors
UNDEF = { ub(t') | ∃ db(t) ∈ DEF /\ t' ∈ pref(t) } Undefined program behaviors
                                                   it is a prefix closure

refDef(ub(t)) = { db(t;t₂) | db(t;t₂) ∈ DEF }
refSig(ub(t)) = { db(t;t₂) | t₂ ∈ Σ*ω }
refUni(ub(t)) = { db(t;t₂) | t₂ ∈ U*ω }     CompCert's guarantee
these are postfix closures

∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refDef(π) => π∪π' ∈ DEF ∪ UNDEF
∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refSig(π) => π∪π' ∉ DEF ∪ UNDEF
∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refUni(π) => π∪π' ∉ DEF ∪ UNDEF

Note that refDef produces refinements that respect any property that
is valid for the semantics ⇓, for example for our instance protected
call stack and memory protection are still valid in the refinements.

A system where properties π containing ub are closed wrt to refDef
allows the programmer to reason in terms of source level programs,
ignoring the rest of the compilation chain.

SCL: A property π is suffix closed or refDef closed iff
     ∀ ub(t,P) ∈π => refDef(ub(t,P)) ∈π

*** Example of undefined property
e.g. we have showed that our program never calls the procedure Error, this is property π₁
     additionally we used an approximate static analysis which tells us that our program
     doesn't UB at least for 3 steps, this is π₂
     The global property that we can guarantee is
     π = { b(t) | pref(t,3) ∈π₁ } which is closed wrt refDef(π₁ ∪ π₂)
     this property is preserved by CCBR (CompCert)

*** Examples of bad traces
- in levels below our language with events Σ we might have extra events
  that are not in Σ. Any trace with such events should be prevented by
  the property.
  e.g. Call Ret ... EraseHDD
  If the system guarantees that we guarantee properties closed wrt to
  refSig then this trace is prevented.
- in levels below our language with events Σ we might not have the same
  abstractions reflected on the valid sequences of events.
  e.g. in C calls follow a stack discipline, in ASM they don't so we
       could observe a trace  C₁ Call C₂ ; C₁ Call C₂ which is not valid 
       at the source.
  If the system guarantees that we guarantee properties closed wrt to
  refDef then this trace is prevented.

** Linked Program Cₛ
*** properties for a component
ψ = n interfaces
Pᵢ ∈ { components compatible with interface i }
Ps ∈ { sets of components compatible with ψ }
DEF(Pᵢ)  = { db(t) | ∃Ps={P₁ ... Pᵢ₋₁, Pᵢ₊₁ ... Pₙ}. ⋈(Ps ∪ {Pᵢ}) ⇓ db(t) }
DEF(Ps) = ⋂ { DEF(Pᵢ)  | Pᵢ ∈ Pₛ }
DEF     = ⋃ { DEF(Ps) | ∃ Ps } = { db | ∃Ps. db ∈ DEF(Ps) } 
UNDEF(Pᵢ) = { ub(t₁,Pᵢ) | ∃ db(t) ∈ DEF(Pᵢ) /\ 
                     t=t₁at₂ /\ a∈Pᵢ } Undefined program behaviors
                                      it is a prefix closure
UNDEF(Ps) = ⋂ { UNDEF(Pᵢ) | Pᵢ∈Ps}
UNDEF = ⋃ { UNDEF(Ps) | ∃Ps }

refDef(ub(t,Pᵢ)) = { db(t;t₂) | db(t;t₂) ∈ DEF }

SCL: A property πᵢ is suffix closed or refDef closed iff
     ∀ ub(t,Pᵢ) ∈πᵢ => refDef(ub(t,Pᵢ)) ∈πᵢ
Corollary: if πᵢ is SCL => πᵢ ∈ DEF ∪ UNDEF(Pᵢ)
if Pᵢ is defined then πᵢ ∈ DEF(Pᵢ)
if Pᵢ is undefined then πᵢ ∈ DEF ∪ UNDEF(Pᵢ)

*** Properties for a linked program
π = ⋂ πᵢ
π ∈ DEF ∪ UNDEF
if Ps is defined then π ∈ DEF(Ps)
if Pᵢ is undefined then πᵢ ∈ DEF ∪ UNDEF(Pᵢ)

*** Properties over traces
We now define properties Πᵢ over the traces of a component.
Each element in t is tagged with a component Pᵢ
filter(t,Pᵢ) = List.filter(fun (e,Pⱼ) -> Pᵢ=Pⱼ, t)

We can define the πᵢ from our Πᵢ
πᵢ = { b(t) | filter(t,Pᵢ) ∈ Πᵢ }

Note: the only properties that can be defined over a partial program
with UB are those that assumes that the program doesn't UB before a
certain length, starting from some of its entrypoints.

*** Catalin's example
TODO

* Satisfaction and its preservation for whole programs
  P satisfies a property π iff
  P ⇓ b => b ∈ π
* Compiler Correctness
Compiler Correctness is generally stated in terms of simulations. CompCert, for
instance, defines it as a backward simulation with refinement. The refinement
part is important because it permits to model several peculiarities of the C
language, e.g. the presence of undefined behaviors at the source language.

CCR (Compiler Correctness with Refinement):
  ∀ b. P↓ ⇓ b => P ⇓ b
               ∨ P ⇓ GoingWrong(prefix(b))

By looking carefully at what this definitions says, we can notice that at the
low level we are guaranteed to observe either the same source level behavior of
the original program or a prefix of a source level trace terminated with
undefined behavior. Basically, the second case tells us that we cannot rely on
what happen after an undefined behavior, i.e. the refinement that takes place at
the low level is arbitrary.

** Vertical definability:
VDEF: P ⇓ₜ b => ∃P'. P'⇓ₛ b

In principle there is no need to talk about compilation, definability
can be seen as a property of the behaviors that we chose to link the
two semantics. It is true for every program.
We can weaken it and prove it only for compiled programs, probably
useful is Nora's backend. In that case only compiled programs can be
backmapped. Def without CC means that ↓ can compile a program P like
it was another program P'. The compiler in general will never produce
something that is not expressable in the source, independently of what
program you start with.

Some simple implications:
CCR + DEF => CCRD
** Compiler Correctness with definability
A possible way to limit the damage caused by undefined behaviors could be to say
something more about the refinement. The idea is to constrain it to what is
possible at the source level.

CCRD:
  ∀ b. P↓ ⇓ b => P ⇓ b
               ∨ (P ⇓ GoingWrong(prefix(b)) ∧ ∃ P'. P' ⇓ b)

With this new definition we are limiting the possible refinements so that they
must be reproducible at the source level by an arbitrary program. This property,
however, could be unsatisfactory depending on how expressive the behaviors are.
For instance, we conjecture that CompCert already satisfies it, because its
events are too coarse and we should always be able to exhibit a legal high-level
program that produces them.

TODO mention Satisfaction for complete programs ?
** Catalin's example Guglielmo
Now that we have the main ingredients for talking about security, we can see
why CCR and CCRD are not enough to allow this kind of preservation:

  Consider TC and UC as, respectively, trusted and untrusted source level components.

  TC is verified, meaning that it is fully defined, FD(TC), and it robusty
  satisfies a property Πₜ.

  UC is not verified, thus it could exhibit undefined behavior at any point
  during its execution.

  Claim:
    CCRD doesn't guarantee PRS
  Proof:
    Let's suppose to have observed ¬Πₜ(filter(trace(b_bad),P)) at the low level after having
    compiled down TC and UC.
      ⋈(TC↓, UC↓) ⇓ b_bad
    by Separate Compilation
      ⋈(TC, UC)↓ ⇓ b_bad
    by CCRD, two cases
      1) ⋈(TC, UC) ⇓ b_bad
         by Robust Satisfaction
           ⋈(TC, UC) ⇓ b_bad => Πₜ(filter(trace(b_bad), P))
         but we know that ¬Πₜ(filter(trace(b_bad), P)), hence this case cannot happen.
      2) ∃ pref ∈ prefixes(trace(b_bad)). ⋈(TC, UC) ⇓ GoingWrong(pref) ∧ ∃ P'. P' ⇓ b_bad
         Firstly, notice that the undefined behavior could have only happend
         because of UC, since FD(TC).
         by Robust Satisfaction
           ⋈(TC, UC) ⇓ GoingWrong(pref, C) =>
             Πₜ(filter(trace(GoingWrong(pref, C)), P) => Πₜ(filter(pref, P))
         therefore, it must be the case that Πₜ(filter(pref, P)) and the bad things
         characterizing b_bad happen after the undefined behavior at the source level.
         we have been able to observe a bad behavior of P at the low level, even
         if P was verified!
** Catalin's example Marco
Applying DEF and CCBR to the whole program is not enough to prevent a
bad behavior.
It is possible to have a bad behavior at the target if we use only
CCBR, as a result of a refinement:
⋈(Ctrusted, Cuntrusted)↓ ⇓ₜ b_bad =>CCBR
let P=⋈(Ctrusted, Cuntrusted) in P ⇓ₛ b \/ P ⇓ₛ pref(b);UB(Cuntrusted)
And that behavior can be picked up by definability.
⋈(Ctrusted, Cuntrusted)↓ ⇓ₜ b_bad ⇒ ∃P'. P' ⇓ₛ b_bad
The intuition is that an UB in any component makes the others lose
guarantees, even if they are f.d.

We need to apply a finer notion, PCCBR.
The intuition is that because we have correct compilation the
behaviors at target cannot be bad, so the example doesn't apply.
P FD and robustly satisfies π: ∀C. C[P] ⇓b => b ∈ π(P)
b_bad ∉ π(P)
C↓[P↓] ⇓ₜ b_bad
=>DEC P↓ ⇓ₜ{C} b_bad
=>PCCBR P ⇓ₛ{C} b_bad   (because P is verified we can do only one case)
=>DEFS ∃C'. C'[P] ⇓ₛ b_bad
This is a contradiction because P robustly satisfies π.

The same holds from intermediate with UB
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBR P ⇓ₛ{C} b' (because P is verified we can do only one case)
=>DEFS ∃C'. C'[P] ⇓ₛ b'
This should be a contradiction because if b_bad is not in π, the same
should hold for any of its refinements.



P unverified
C↓[P↓] ⇓ₜ b_bad
=>DEC P↓ ⇓ₜ{C} b_bad
=>PCCBR P ⇓ₛ{C} b_bad \/ P ⇓ₛ{C} pref(b_bad);UB(P) 
=>DEFS ∃C'. C'[P] ⇓ₛ pref(b_bad);UB(P)
we can guarantee up to the pref(b_bad).



What if P is not verified?
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBR P ⇓ₛ{C} b'' /\ (b''=b' \/ b''=pref(b');UB(P))
=>DEFS ∃C'. C'[P] ⇓ₛ ??
Is this a contradiction? What is the connection between b_bad and b''?


What if P is not verified and we use PCCBD?
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBD P ⇓ₛ{C} b' \/ (P ⇓ₛ{C} pref(b');UB(P) /\ ∃P'. P' ⇓ₛ{C} b)
left=>DEFS ∃C'. C'[P] ⇓ₛ b'??
right=>DEFS ∃C'. C'[P] ⇓ₛ b'??

Is this a contradiction? What is the connection between b_bad and b''?

* Robust Satisfaction and its preservation for linked programs
An interesting scenario that we can use to validate our definitions is the one in
which we mix verified and unverified/untrusted components. Here we want to see
to what extent our verified components maintain their desired behaviors.

First of all, we must introduce the notions of linking and separate compilation.

Linking:
  Given components C and P, their linking is represented as ⋈(C, P)
TODO define better

Separate Compilation:
  ⋈(C1, C2)↓ ⇓ b <=> ⋈(C1↓, C2↓) ⇓ b
TODO define better

A property Πₚ is predicate on sequences of events (a trace).
We can see it also as the set πₚ of traces for which such predicate holds.

Πₚ : t -> Prop
πₚ := { t | Πₚ(filter(t, P)) }

RS Robust Satisfaction
  ∀C. C[P]⇓b => b∈π
TODO if π is refSig closed then this definition is enough, if we want
  to be more explicit use the one below

RS (Robust Satisfaction with Undefined Behavior):
  ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P)) ∨
         (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P)))

An additional definition that we need is the one which allows us to deal with
verified programs that can never exhibit undefined behaviors.

FD (Fully Definedness):
  ∀ C b. ¬ (⋈(C, P) ⇓ GoingWrong(b))

Corollary: if P can exhibit undefined behavior at any point, ∀ t. Πₜ(t)
Proof:
  by RS, second case
    ⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref), P)
  since undefined behavior can happen at any point, t could ε
  therefore, assuming ∃ C. ⋈(C, P) ⇓ GoingWrong(ε, P)
  we have ∀ ref. Πₚ(filter(ε;ref), P), that is
    ∀ t. Πₚ(filter(t, P))

Robust Satisfaction is defined independently of the existence of a compiler
between different languages. In our case, however, we are interested in
preserving it after we have done a compilation pass on our program.  

PRS (Preservation of Robust Satisfaction):
  (∀C b. C[P]⇓b => b∈π) => (∀c b. c[P↓]⇓b => b∈π)
TODO if π is refSig closed then this definition is enough, if we want
  to be more explicit use the one below

PRS (Preservation of Robust Satisfaction):
  (∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
          (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P)))) =>
  (∀ c b. ⋈(c, P↓) ⇓ b => Πₚ(filter(trace(b), P)))

* Robust Compilation
Starting from CCR and CCRD we can obtain the equivalent for a component using the partial semantics.
PCCR: P↓ ⇓ᵢ{C} b => P ⇓ₛ{C} db \/ P ⇓ₛ{C} ub(pref(b),P)                   Partial Compile Correctness Backward and Refined
PCCRD: P↓ ⇓ᵢ{C} b => P ⇓ₛ{C} db \/ (P ⇓ₛ{C} ub(pref(b),P) /\ ∃P'. P' ⇓ₛ{C} db)  Partial Compile Correctness Backward and Defined

We can go back to complete semantics obtaining the following
RC4:  ∀c FD. c[P↓] ⇓ᵢ db => ∃C. C[P] ⇓ₛ db \/ C[P] ⇓ₛ ub(pref(b),P)
RC4D: ∀c FD. c[P↓] ⇓ᵢ db => ∃C. C[P] ⇓ₛ db \/ (C[P] ⇓ₛ ub(pref(b),P) /\ ∃P'. C[P'] ⇓ₛ db)

TODO should C be defined or fully defined?
TODO how do we prove PCCR? we only have CCR
** proof RC4 implies CCR

Proof.
n-DEC for all Pᵢ↓
PCCRD for all Pᵢ↓
n-COMP to obtain the shortest prefix of all ub(pref(b),Pᵢ)


C↓P↓ ⇓b => CP ⇓b ‌\/ CP ⇓ub(pref(b),C) \/ CP ⇓ub(pref(b),p) 



RC4(P, cs, db) = ∃Cs. ⋈(Cs,P) ⇓ₛ db \/ ⋈(Cs,P) ⇓ₛ ub(pref(db),P)
H1: ∀Pᵢ. RC4(Pᵢ, (P\Pᵢ)↓, db)
H2: ∀ b. P↓ ⇓ db
GOAL: P ⇓ db ∨ P ⇓ ub(prefix(db),Pᵢ)


H2=⋈(P₁,...,Pₙ)↓ ⇓ₜ db =>SC
⋈(P₁↓,...,Pₙ↓) ⇓ₜ db =>H1
∃Csᵢ.
(1) ⋈(Csᵢ,Pᵢ) ⇓ₛ db ‌\/
(2) ⋈(Csᵢ,Pᵢ) ⇓ₛ ub(pref(db),Pᵢ)

⋈(Csᵢ, Pᵢ)↓ ⇓ db'

Suppose ↓ is wrong, then either:
1) ⋈(Csᵢ, Pᵢ) ⇓ db
   db'  ≠ db
2) ⋈(Csᵢ, Pᵢ) ⇓ ub(t, Pᵢ)
   ¬∃ prefix(db') = t

(∀Pᵢ. ∃Csᵢ. ⋈(Csᵢ,Pᵢ) ⇓ₛ db 



Separate Compilation
SC: ⋈(P₁,...,Pₙ)↓ ⇓b => ⋈(P₁↓,...,Pₙ↓) ⇓b
in our case seems by definition because compiling a whole program consists in concatenating the compilation of its components: ⋈(P₁,...,Pₙ)↓ = ⋈(P₁↓,...,Pₙ↓).
However in general this might not be true, it looks provable semantically if we show that we can do a n-way-decomposition to n partial Pᵢ and then a n-way-composition to get back to P.

** proof of RC4 for our instance
∀c FD. c[P↓] ⇓ᵢ db =>DEC
P↓ ⇓ₜ{C} db =>PCCR 
P ⇓ₛ{C} b' /\ (b'=db \/ b'=ub(pref(db),P) =>DEF in both cases
∃C. C[P] ⇓ₛ b' /\ (b'=db \/ b'=ub(pref(db),P)

** proof that RC4 (plus other stuff) satisfies PRS
First we need this Lemma to apply RC4 when the context is not defined.

Closed wrt FD context (not needed from the target)
HR: ∀C. C[P]⇓b => ∃C' FD. C'[P]⇓b' /\ filter(b)=filter(b')
this implies? the following which is more intuitive but less usable in the proof
    ∀C. C[P]⇓b /\ b∈π => ∃C' FD. C'[P]⇓b' /\ b'≥b /\ b'∈π

TODO Proof
looks like a DECR and DEF at the same level
I could use DECR but I'd like to have a b' which is not longer that b,
ideally I can make a C' that instead of doing ub, as soon as it is
called terminates. This leads to the same filtering for b.



TODO the following proof is valid with different choiches of π. Our
instance can preserve π that are suffix closed wrt refDef, however if
we start with π that are suffix closed wrt to refSig the proof still
holds. The proof holds also for closed wrt to refUni, that would be
the properties preserved by compcert


Proof that RC4+HR+SCL implies PRS.
Assume h1: (∀b C. C[P]⇓b => b∈π) 
       h2:  ∀b c. c[P↓]⇓b
- C FD, P FD
h2 =>RC4
∃C. C[P] ⇓ₛ b =>h1
b∈π
- C FD, P not FD
h2 =>RC4
∃C. C[P] ⇓ₛ pref(b);UB(P) =>h1
pref(b);UB(P) ∈π =>SCL
b∈π
- C not FD, P FD
h2 =>HR
∃c' FD. c'[P↓]⇓b' /\ filter(b)=filter(b') =>RC4
∃C. C[P] ⇓ₛ b' /\ filter(b)=filter(b') =>h1
b'∈π /\ filter(b)=filter(b') =>
b∈π
- C not FD, P not FD
h2 =>HR
∃c' FD. c'[P↓]⇓b' /\ filter(b)=filter(b') =>RC4
∃C. C[P] ⇓ₛ pref(b');UB(P) /\ filter(b)=filter(b') =>h1
pref(b');UB(P)∈π /\ filter(b)=filter(b') =>SCL
b'∈π /\ filter(b)=filter(b') =>
b ∈π

* Robust Execution
What we would like to have is something finer-grained that, ideally, replaces
only those components which cause problems.

RE (Robust Execution):
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
Notes:
  – ρ is a low level program
  – compiler correctness seems to be not required
  – NEW_RC_DC can be obtained by instantiating ρ with both compiled (P) and
    arbitrary (C) components and then looking just at the backmapping of C
  – this property is more general, since it works for arbitrary low level
    components. My intuition is that our environment of execution guarantees the
    backmapping argument for every component, no matter where it comes from
    (e.g. compiled or hand-written).

Lemma:
  RE => NEW_RC_DC
Proof:
  Given an arbitrary low level component c and a source level component P, we
  want to show that
    c[P↓] ⇓ b  ⇒  ∃C. FD(C) ∧ C↓[P↓] ⇓ b
  That is, we observed c[P↓] ⇓ b and we need to exhibit a source level component
  C such that
    C fully defined ∧ C↓[P↓] ⇓ b
  by RE instantiated with c and P↓, we can pick the case in which we backmap c
    ∃ C. FD(C) ∧ C↓[P↓] ⇓ b

Lemma:
  CCR ∧ RE => RC4
Proof:
  should follow from multiple applications of RE and then CCR

** Preservation of Robust Satisfaction by means of CCR and RE
Main Theorem:
  CCR ∧ RE => PRS
Notes:
  if we prove that our compiler is correct (CCR) and that our execution
  environment is robust (RE), then it means that robust satisfaction is
  preserved no matter what other components do (e.g. undefined behavior)
Proof:
  Given a source level component P and a property Πₚ, we want to show PRS:
  We know that RS holds at the source level
    ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
           (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P))).
  Given arbitrary c (sets of low level components) and b such that ⋈(c, P↓) ⇓ b,
  we have to show that Πₚ(filter(b, P))

  by RE instantiated with cᵢ ∈ c and P↓, we can pick the case in which we backmap cᵢ
    ∃ Cᵢ. FD(Cᵢ) ∧ ⋈(c\cᵢ, Cᵢ↓, P↓) ⇓ b
  we can do this last thing repeatedly for all the cᵢ ∈ c, until we have all Cᵢ such
  that ∀ i. FD(Cᵢ) ∧ ⋈(C₁↓, ..., Cₙ↓, P↓) ⇓ b
  For brevity, C = {C₁, ..., Cₙ}
  by Separate Compilation
    ⋈(C, P)↓ ⇓ b
  by CCR, three cases
    1) ⋈(C, P) ⇓ b
       by RS at the source we have Πₚ(filter(trace(b), P)), our goal
    2) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, C)
       This cannot happen, since ∀ i. FD(Cᵢ)
    3) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, P)
       by RS at the source we have ∀ ref. Πₚ(filter(pref;ref, P))
       we can destruct trace(b) as trace(b)=pref;t
       then we can instantiate ref with t and obtain Πₚ(filter(pref;t), P)
       this means Πₚ(filter(trace(b), P)), our goal
** Our Instance
Proving RE in our context requires different ingredients:
  1) Partial Semantics
  1) Decomposition:
     A whole program can be simulated by the very same program without some
     components in the partial semantics.
  2) Composition:
     Two compatible partial programs that have the same behavior in
     the partial semantics can be simulated in the complete semantics by a whole
     program obtained by merging them.
  3) Component Definability:
     Given a behavior observed at the low level, we can exhibit a fully defined
     source component which exactly reproduces it.
  4) Forward Compiler Correctness for partial programs:
     The compiler preserves the program semantics when we are in the partial
     semantics.

Decomposition and Composition are simulations which should be provable.

Compiler Correctness for partial programs should follow from CCR.

Definability is definitely the most difficult one. For finite traces we should
be able to prove it, but for the infinite ones we have no clue about how to
proceed. A possibility could be to give guarantees on all the finite traces that
are prefix of an infinite behavior.

*** Proof
We want to show that
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
That is, we have ρ such that ⋈(ρ) ⇓ b and we want to show
  ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
We show the above fact for an arbitrary pᵢ ∈ ρ.
by Decomposition
  pᵢ ⇓{p\pᵢ} b
by Definability
  ∃ Pᵢ. FD(Pᵢ) ∧ Pᵢ ⇓{ρ\pᵢ} b
by Forward Compiler Correctness for partial programs
  Pᵢ↓ ⇓{ρ\pᵢ} b
by Decomposition
  ⋈(p\pᵢ) ⇓{pᵢ} b
by Composition
  ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
we have that
  ∃ Pᵢ FD(Pᵢ) ∧ ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
which is what we wanted to show.
* Mutual Distrust
An interesting case is the one with more than two mutually distrustful source
level components. There are several characterization of it, the iterative one
being the most promising.

RC4(P, cs, db) = ∃Cs. ⋈(Cs,P) ⇓ₛ db \/ ⋈(Cs,P) ⇓ₛ ub(pref(db),P)

MD:
P = {P₁, ..., Pₙ}
⋈(P)↓ ⇓ b => ∀ Pᵢ. RC4(Pᵢ, (P\Pᵢ)↓, b)

* Bits and pieces
** Partial Definability
PDEF: PP ⇓ₜ b  => ∃PP'. PP'⇓ₛ b
PDEF on all components implies DEF on whole programs: WP ⇓ₜ b  =>? ∃WP'. WP'⇓ₛ b
WP ⇓ₜ b => ⋈(p₁,...,pₙ) ⇓ₜ b 
       =>DEC ∀pᵢ. pᵢ ⇓pt b 
       =>PDef ∀pᵢ. ∃Pᵢ'. Pᵢ' ⇓ps b 
       =>COMP ⋈(P₁',...,Pₙ') ⇓ₛ b 
       => WP'⇓ₛ b
TODO: If there is UB in b (e.g. if we are at intermediate instead of
target) then we need to use DECR and recheck the proof

** De/composition with refinement
If we want to have UB in a language then we need to add refinement to its decomposition.
If the context does UB then the partial context refines it.
DECR: ∀C. C[P] ⇓ b => P ⇓{C} b' /\ (b'=b ‌\/ b=pref(b');UB(C))       (note that P can do UB, there is no refinement for P)

Simmetrically we defined composition with a refinement:
COMPR: C ⇓{P} b /\ P ⇓{C} b => C[P] ⇓ b \/ C[P] ⇓ pref(b);UB
TODO CHECK ALL UB CASES

Definability on the same level (the old definability):
DEFS: P ⇓{C} b => ∃C. C[P] ⇓ b      (on the Same level. P can do UB and C cannot)

** Preservation of Robust Satisfaction by means of CCR and RE
Main Theorem:
  CCR ∧ RE => PRS
Notes:
  if we prove that our compiler is correct (CCR) and that our execution
  environment is robust (RE), then it means that robust satisfaction is
  preserved no matter what other components do (e.g. undefined behavior)
Proof:
  Given a source level component P and a property Πₚ, we want to show PRS:
  We know that RS holds at the source level
    ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
           (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P))).
  Given arbitrary c (sets of low level components) and b such that ⋈(c, P↓) ⇓ b,
  we have to show that Πₚ(filter(b, P))

  by RE instantiated with cᵢ ∈ c and P↓, we can pick the case in which we backmap cᵢ
    ∃ Cᵢ. FD(Cᵢ) ∧ ⋈(c\cᵢ, Cᵢ↓, P↓) ⇓ b
  we can do this last thing repeatedly for all the cᵢ ∈ c, until we have all Cᵢ such
  that ∀ i. FD(Cᵢ) ∧ ⋈(C₁↓, ..., Cₙ↓, P↓) ⇓ b
  For brevity, C = {C₁, ..., Cₙ}
  by Separate Compilation
    ⋈(C, P)↓ ⇓ b
  by CCR, three cases
    1) ⋈(C, P) ⇓ b
       by RS at the source we have Πₚ(filter(trace(b), P)), our goal
    2) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, C)
       This cannot happen, since ∀ i. FD(Cᵢ)
    3) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, P)
       by RS at the source we have ∀ ref. Πₚ(filter(pref;ref, P))
       we can destruct trace(b) as trace(b)=pref;t
       then we can instantiate ref with t and obtain Πₚ(filter(pref;t), P)
       this means Πₚ(filter(trace(b), P)), our goal
** Our Instance
Proving RE in our context requires different ingredients:
  1) Partial Semantics
  1) Decomposition:
     A whole program can be simulated by the very same program without some
     components in the partial semantics.
  2) Composition:
     Two compatible partial programs that have the same behavior in
     the partial semantics can be simulated in the complete semantics by a whole
     program obtained by merging them.
  3) Component Definability:
     Given a behavior observed at the low level, we can exhibit a fully defined
     source component which exactly reproduces it.
  4) Forward Compiler Correctness for partial programs:
     The compiler preserves the program semantics when we are in the partial
     semantics.

Decomposition and Composition are simulations which should be provable.

Compiler Correctness for partial programs should follow from CCR.

Definability is definitely the most difficult one. For finite traces we should
be able to prove it, but for the infinite ones we have no clue about how to
proceed. A possibility could be to give guarantees on all the finite traces that
are prefix of an infinite behavior.

*** Proof
We want to show that
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
That is, we have ρ such that ⋈(ρ) ⇓ b and we want to show
  ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
We show the above fact for an arbitrary pᵢ ∈ ρ.
by Decomposition
  pᵢ ⇓{p\pᵢ} b
by Definability
  ∃ Pᵢ. FD(Pᵢ) ∧ Pᵢ ⇓{ρ\pᵢ} b
by Forward Compiler Correctness for partial programs
  Pᵢ↓ ⇓{ρ\pᵢ} b
by Decomposition
  ⋈(p\pᵢ) ⇓{pᵢ} b
by Composition
  ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
we have that
  ∃ Pᵢ FD(Pᵢ) ∧ ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
which is what we wanted to show.
* Robust Execution with Undefined Behavior at target
RE (Robust Execution):
  ∀ ρ={p₁,...,pₙ}.
    (⋈(ρ) ⇓ b =>
      ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b) ∨
    (⋈(ρ) ⇓ GoingWrong(t, pᵢ) =>
      (∀ pⱼ s.t. j ≠ i. ∃ Pⱼ. FD(Pⱼ) ∧ ⋈(ρ\pⱼ ∪ Pⱼ↓) ⇓ GoingWrong(t, pᵢ)) ∧
      (∃ Pᵢ b'. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b' ∧ trace(b') = t)
