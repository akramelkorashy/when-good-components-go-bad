\documentclass[12pt,a4paper]{article}

\usepackage{mathtools,amsmath,amsfonts,amssymb,amsthm,bbm}
\usepackage{amscd,xy}
\usepackage{enumerate}
\usepackage{color,graphicx,xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{soul}

\newtheorem{lemma}{Lemma}

\title{Notes from Hangouts + Skype calls}
\author{Adrien, Akram, Carmine, Catalin, Deepak, Jeremy, Rob}
\date{April 22-24, 2020}

\newcommand{\todo}[1]{$\rightarrow$ \textcolor{red}{#1}}

\newcommand{\Mem}{\text{Mem}}

\begin{document}
\maketitle
\tableofcontents

\section{Random notes while going through 
	the code with Rob (Apr 22nd)}

\begin{itemize}
\item In the file \texttt{Intermediate/Machine.v}, in the
 \texttt{program} record definition, notice that the field 
 \texttt{prog\_buffers} is a static description of the memory.
 
The left \texttt{nat} option describes the \textit{size} of a buffer.
The right \texttt{list value} option describes instead the
initial \textit{contents}
of the buffer directly.

\item Although the 
semantics of the intermediate language seems to \textit{not} prohibit
forging pointers, forging pointers is still prohibited through
the well-formedness conditions.

In particular, if one looks at the syntax and semantics of
\texttt{IConst v r}, one would think that \texttt{v} can be any
pointer value.

However, a program that uses \texttt{IConst} to forge
pointers is not
a well-formed program to begin with. In particular, in 
\texttt{Intermediate/Machine.v}, the definition
\texttt{well\_formed\_instruction} guarantees that 
the use of \texttt{IConst} does not constitute forging of pointers.

In fact, the condition on \texttt{IConst} was not complete. It allowed
any component to access any other component's static buffer.
We should add an extra conjunct that ensures 
\texttt{Pointer.component ptr = C}. 
\todo{Check that this conjunct is added.}

Notice that this way of guaranteeing unforgeability is different
from the way CHERI works.
In CHERI, a pointer (read, capability) value is only a 
\textit{runtime} value. The syntax of instructions (in CHERIExpress)
does not even contain a base value for a capability.
Instead, the way the program gets hold of capabilities is by looking them
up in known registers (i.e., known by convention).
The capability values are placed in these \textit{known registers}
by the loader, not the compiler.

\item In order for a component in CHERI to always have access
(through the right capabilities) to its
static memory even after it gets (back) control from another 
component, the CHERI ISA 
requires that the Call (and Return) instruction
place the right capabilities in the known registers.
This is typically done by means of a \textit{trusted call-stack}
that the kernel maintains. A Call and a Return thus cause a trap
that is handled by a kernel procedures that pushes/pops the
trusted call stack and places the capabilities in the known
registers.

All of this trusted-call business is not needed in our intermediate
language. Instead, the program text can hardcode the necessary
pointers that point to the static buffers.
And well-formedness guarantees that each component does not
hardcode any more pointers than what it needs.

\item Notice that in our intermediate language
both the Call and Return instructions
clear (invalidate) the registers.

\item Having known that the initial access to memory (i.e., to
the static buffers) is achieved by hardcoding pointer
values in the program, one can now compute the \textbf{initial
set of reachable blocks} per component \texttt{cid}
of program \texttt{p} as follows:\\
$\mathtt{cid} \mapsto \underset{\{\mathtt{ptr}
	 ~\mid~ \mathtt{IConst ~(Pointer ~ptr)~ \_}~ \in
	 \mathit{code}(\texttt{p}, \texttt{cid}) \}}{\bigcup} 
 \mathit{reachable\_blocks}
 (\texttt{ptr}, \mathit{init\_mem}(\texttt{p}))
$

\item \todo{In \texttt{Recombination.v}, we need to figure out
what the right function \texttt{merge\_addrs} should look like.}


\end{itemize}

\section{Discussions about the trace models on 22nd-24th Apr}

This discussion started during the Hangouts call on 
\textbf{Apr 22nd 2020},
and then continued the two days after during the all-hands Skype call
on \textbf{Apr 23rd and Apr 24th}.

\begin{itemize}
\item Back in Saarbrucken (in January or February),
 we had agreed that we would go for
an informative trace model that unlike the model of CapablePtrs,
records individual read/write events to the shared memory instead of
only recording at border states a less
informative snapshot of the shared memory.

\item The motivation for going for this informative trace model
was that it would make the \textbf{construction of lvalues}
easier. In particular, we probably thought that when we have
the read events to shared memory recorded, we will not need
any \textbf{book-keeping} for holding pointers to the shared memory.
This thought is wrong.

\item Read events from only the shared memory are not sufficient
for re-constructing the full access sequence that leads
to a location in shared memory.
To re-construct the full access sequence, one would also need
to have recorded \textbf{all read/write events} including those
on private memory.

\item (Jeremy/Catalin:)
In fact, even \textbf{all read/write events are not sufficient}.
One would need to know what operations happened on registers.
For example, one would need to know whether a pointer value
loaded to register \texttt{r1} has been incremented, or moved to 
another register, etc..
Thus, in order to really re-construct the whole program as
a function
of just the trace,
 one may need to go for a \textbf{code-based back-translation}, as
 Catalin put it.

\item (Akram:) Instead of going for this
full-blown informative trace that indeed just mimics every instruction
and models it as a trace event, the other approach is to 
just stick with the model that
\textbf{records all \st{reads and} writes to both shared and 
	private memory}.
And in this model, in order to
\textbf{construct an expression that evaluates
to a desired pointer value},
one would rely on the following facts:

\begin{enumerate}
\item \textbf{Every pointer value} that appears on the trace
\textbf{must be in the reachability set} that is computed from
either:
\begin{enumerate}
\item \st{an earlier pointer value that appeared on the trace, or}
\item a hardcoded constant
\end{enumerate}

\item The fact that
a pointer value \texttt{(cid, bid)} is in the reachability set 
computed from a location $\mathtt{(cid_0, bid_0)}$
 implies the existence of a path
from $\mathtt{(cid_0, bid_0)}$ to $\mathtt{(cid, bid)}$. (This is
the lemma we get from ssreflect.fingraph.)
\item \label{path-expr}
The existence of a path from $\mathtt{(cid_0, bid_0)}$
 to \texttt{(cid, bid)}
 means the existence of an expression that evaluates to 
 \texttt{(cid, bid, \_)}. Moreover, this expression is a sequence
 of derefs that needs to start with an expression $\mathtt{e_0}$ that 
 evaluates to $\mathtt{(cid_0, bid_0)}$.

\item In order to preserve the first fact,
 it is sufficient to mimic all the memory events that appear
 on the trace. This preserves the equality relation between
 the memory of the back-translated program and the given program.
\end{enumerate}

\item We decided the trace will \textbf{not only record the writes, but
additionally also the memory dump of the shared memory}.
This trace is the one that is used for back-translation.

\item This way, we should be able to prove that the back-translation
produces the same trace, i.e., the same shared-memory dumps at
border states, and also the same write events.

\item The memory relation between the back-translated program and
the given program is almost equality (equality 
but excluding the part of memory that holds the book-keeping 
counter(s)).

\item Recording all the writes, not just the shared writes, is 
necessary for preserving memory equality.
Memory equality (not just shared-memory equality) is necessary
for avoiding book-keeping.
We are able to avoid book-keeping 
because we can rely on memory equality to
\textbf{translate a path in the target 
	memory to a path in the source memory}.

\item The existence of a path in the source memory then means the
existence of an expression (fact \ref{path-expr} above).

\item For the proof of Recombination, 
we go to the uninformative trace,
which is the fully-abstract trace (i.e., the one with only
the memory dumps, after dropping the write events).

\item \todo{(Akram:) It is not clear to me whether
the decision to not put the reads on traces 
(in the case of the robust safety proof)
is compatible with the need
for reads for the sake of the tree representation
of a set of traces. (The reads to shared memory in 
Jeremy's technique constitute
nodes in the tree.)
}
\end{itemize}

\section{More thoughts from the Apr 24th meeting}

\begin{itemize}
\item Deepak suggested that there may be a more general
argument to be made about back-translation. The argument is one
that follows from computability theory results.

Deepak's idea is that one can view a context as a function
from trace prefixes to trace actions (in case of robust safety), or
to view the context as a function from sets of trace prefixes 
to sets of trace actions (?) in other cases.

Catalin mentioned that he saw somewhere in an FCS paper
a connection between secure compilation and computability.

(Akram:) My worry is that mechanizing such an argument
(even if the argument is provided by a library of Turing machines
in Coq) might involve the construction of a
universal Turing machine
as a program in our source language, which is probably a non-trivial
construction.

\item Catalin pointed out that emulating all the memory
events (including private ones)
 that happen in the target is in general not desirable,
especially if the target can make out-of-bounds accesses
and the source cannot.

(Akram:) Not sure about all the details that would
make this emulation not work.

Anyways, as Catalin points out, it seems we should be able to
get away with it in our models here.
\end{itemize}

\end{document}