\documentclass[12pt,a4paper]{article}

\usepackage{mathtools,amsmath,amsfonts,amssymb,amsthm,bbm}
\usepackage{amscd,xy}
\usepackage{enumerate}
\usepackage{color,graphicx,xcolor}
\usepackage[hidelinks]{hyperref}

\newtheorem{lemma}{Lemma}

\title{Notes from talk in Saarbrucken}
\author{Jeremy, Akram, Adrien}
\date{February 2nd, 2020}

\newcommand{\todo}[1]{$\rightarrow$ \textcolor{red}{#1}}

\newcommand{\Mem}{\text{Mem}}

\begin{document}
\maketitle
\tableofcontents


\section{TODOLIST}
This is a list of what should be taken care of before we can start doing actual proofs. 
Both \textbf{on paper} and \textbf{in Coq}.

\begin{enumerate}
\item For both source and intermediate, we have to:
\begin{itemize}
\item Decide and write the memory model (CompCert memory model, as it is now, but without pointer forging)
\item Write the syntax down (Jeremy is doing it on paper)
\item Write both small step semantics (informative and non-informative)
\begin{enumerate}[$+$]
\item State the lemmas relating those semantics ("compatibility lemmas")
\item Check everything goes well when going to the (finite) trace semantics\\
(we don't need infinite traces, be it for RSP or for RFrXP)
\end{enumerate}
\end{itemize}
\item Work on 'High-level proof' (should not be hard)
\begin{itemize}
\item State and prove the lifting of back-translation from informative to non-informative traces
\item State the main results for the actual languages (back-translation, recomposition, etc)
\end{itemize}
\end{enumerate}

\todo{Someone should also remove all the 'Search', 'Print', etc commands that 
are all around the coq code.}

\section{What changes have been already implemented at the beginning of this discussion}
We are currently working on the "dynamic-sharing-playground" branch, on Roberto's "when-good-components-go-bad" git on gitlab.inria.fr.
\begin{enumerate}
\item Changes to the events in \texttt{Common/Traces.v} and \texttt{CompCert/Events.v}
\item Changes to the target language semantics in \texttt{Intermediate/CS.v}
\item Akram's work on reachability (as a reminder: it is useful for defining 'well-formedness' of traces, for back-translation) in \texttt{Common/Memory.v}\\
\todo{Someone should look at this development, at the request of Akram, who's not 
very comfortable with coq yet}
\end{enumerate}

\section{Syntax of source and target languages}
The syntax of the \textbf{source and target languages should not change}, actually!! 
To add sharing, we only need to change the semantics (when a function is called with 
a pointer as argument, we do not prevent it). For capabilities, we get it from 
Compcert's memory model (for free!), as long as we don't have \textbf{forgeability} of 
pointers or block ids. This was already the case, forgeability was already impossible. 
That means the syntax of source and target languages does not change!


%\paragraph{Forgeability}
The source language semantics is located 
in \texttt{Source/CS.v}. For now we are writing that on paper.\\
For detailed notes on syntax, cf. Jeremy's notes.

\section{Semantics of the intermediate ('target') language}
Reachability was added to the informative semantics of the 
intermediate language, which was not needed, and we should remove: 
we don't have to compute whether trace events should appear 
\emph{because both reads and writes (including private) should appear on the trace.}

On the other hand, reachability information should still be part of the 
non-informative semantics, because it is useful for 
back-translation and well-formedness.

\paragraph{Two Ideas:}
\begin{enumerate}
\item [1.(Adrien)] Define the \emph{small-step} non-informative semantics directly by using 
the informative one, just erasing the label (we discussed this yesterday); then 
we need to keep reachability information along execution, even though it's not used 
to check anything and doesn't appear on the labels.
\item [2.(Akram)] Adding memory on the cross-component calls and returns (border) of 
the informative semantics, to make 
going to non-informative easier; but then, when doing back-translation, 
we have to check the memory is actually the right one, which might be 
very heavy. Might not be worth the payoff.
\end{enumerate}


\paragraph{Reminder of why we want to keep reachability information along the execution.} 
It's because it will (probably) make our life easier during recomposition proof: 
a simulation that only relate states is not very informative, by relating also 
auxiliary states (i.e., reachability information). [Akram]

\paragraph{Another idea:} [Jeremy]
Having 3 semantics instead of 2: 
Informative, non-informative + reachability auxiliary state (for back-translation), 
and non-informative without reachability. The reason to add this third semantics (that 
we would have to relate to the other two, but that should probably not be hard) 
is to have a semantics that is easy to read and understand (say for a reviewer or 
someone discovering the code), without 'noise' or extra 
informations.

Having 3 semantics might be quite 'noisy' in itself though, to see.

\todo{Write an email to everybody about the discussion above!!!}


\section{Reviewing Akram's Reachability}

We reviewed Akram's reachability code; 
it consists mainly computable functions using fsets, fmaps, and 
proofs about these functions.
The discussion mainly gravitated 
around the idea that we might be able to rewrite all this 
in  a much more efficient (and easier to use) fashion, 
using non-computable inductive predicates and such (in a way closer 
that what we usually do in coq). 

We discussed whether it was feasible. 
The kind of properties you would actually need about 
reachability:
\begin{lemma}[Soundness of reachable addresses]
If $(s,e)\rightarrow^* (s',v)$ and $v$ is a pointer $p$, then $p\in \mathtt{reachable\_addresses}(s'.\Mem,\_).$
\end{lemma}
(recall that $s$ can only grow along the execution: once a capability is given, 
it cannot be taken back, so the reachable adresses from $s$ are included in those from $s'$, 
as well as any along the execution).

\begin{lemma}[Effect of store on reachability]
If $p\in \mathtt{reachable\_addresses}(m,\text{set\_of\_pointers})$, and some conditions on $a,v,p$, 
then $p\in \mathtt{reachable\_addresses}(m[a\mapsto v],\text{set\_of\_pointers})$.\\
(in the actual lemma there are more conditions on $a,v,p$\dots)
\end{lemma}


For a tentative definition, see Jeremy's notes.


\paragraph{wait wait wait:}Doing this, we cannot dump the shared memory on the trace (or can we? $\rightarrow$ it would make 
the small step semantics undecidable). So the trace semantics is not 
fully abstract any more? Is that an obstacle for recomposition?  

The discussion continued between Akram and Jeremy, to discuss\dots

\end{document}