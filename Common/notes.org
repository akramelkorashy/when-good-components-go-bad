* Behaviors and events
** Events and traces
Let's assume that there is a hierarchy of expressiveness on our
languages, such that the each language is less expressive than the
language it is compiled to. We define for each language a set of
events Σ, where for our instance Σₛ ⊆ Σᵢ ⊆ Σₜ.
We also use the notation t for a trace of events (finite or infinite).

** Behaviors
behaviors are constructors over traces that we split in defined
and undefined. Note here is left implicit that div is the only one
that can have an infinite trace.

db := term(t) | div(t)
b := db | ub(t)

** Whole Program
DEF   = { db(t) | ∃P. P⇓db(t) }                    Defined programs behaviors
UNDEF = { ub(t') | ∃ db(t) ∈ DEF /\ t' ∈ pref(t) } Undefined program behaviors
                                                   it is a prefix closure
TODO: we assume a program can always ub

refDef(ub(t)) = { db(t;t₂) | db(t;t₂) ∈ DEF }
refSig(ub(t)) = { db(t;t₂) | t₂ ∈ Σ*ω }
refUni(ub(t)) = { db(t;t₂) | t₂ ∈ U*ω }     CompCert
these are postfix closures

∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refDef(π) => π∪π' ∈ DEF ∪ UNDEF
∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refSig(π) => π∪π' ∉ DEF ∪ UNDEF
∀π ⊆ DEF ∪ UNDEF. π' is closed wrt refUni(π) => π∪π' ∉ DEF ∪ UNDEF

Note that refDef produces refinements that respect any property that
is valid for the semantics ⇓, for example for our instance protected
call stack and memory protection are still valid in the refinements.

A system where properties π containing ub are closed wrt to refDef
allows the programmer to reason in terms of source level programs,
ignoring the rest of the compilation chain.

SCL: A property π is suffix closed or refDef closed iff
     ∀ ub(t,P) ∈π => refDef(ub(t,P)) ∈π

What about an equivalence?
π~π' <=> (∀db. db ∈ π <=> db ∈ π')
∀π ⊆ DEF ∪ UNDEF. ∃π' ⊆ DEF. ∀ ub ∈ π. refDef(ub) ⊆ π' /\ π ~ π'

TODO: 
The other option is to change the definition of satisfaction so that π
is only defined over DEF and if a semantics produces an ub the match
it correctly inside π.

     
*** Examples of bad traces
- in levels below our language with events Σ we might have extra events
  that are not in Σ. Any trace with such events should be prevented by
  the property.
  e.g. Call Ret ... EraseHDD
  If the system guarantees that we guarantee properties closed wrt to
  refSig then this trace is prevented.
- in levels below our language with events Σ we might not have the same
  abstractions reflected on the valid sequences of events.
  e.g. in C calls follow a stack discipline, in ASM they don't so we
       could observe a trace  C₁ Call C₂ ; C₁ Call C₂ which is not valid 
       at the source.
  If the system guarantees that we guarantee properties closed wrt to
  refDef then this trace is prevented.

*** Example of undefined property
e.g. we have showed that our program never calls the procedure Error, this is property π₁
     additionally we used an approximate static analysis which tells us that our program
     doesn't UB at least for 3 steps, this is π₂
     The global property that we can guarantee is
     π = { b(t) | pref(t,3) ∈π₁ } which is closed wrt refDef(π₁ ∪ π₂)
     this property is preserved by CCBR (CompCert)

other examples could include conditional properties of the form:
- unless the program receives a "potentially unsafe" input it does not
  have undefined behavior, we could use formal verification to prove
  that *some* (but not all) of the inputs are safe

other examples could make use of the interfaces:
- If I know by looking at the allowed calls that from `main` to `bad`
  there is are only certain paths of calls, then we can conclude that
  `bad` can only happen if one of these paths is taken

** Linked Program Cₛ
*** Properties for a component
ψ = n interfaces
Pᵢ ∈ { components compatible with interface i }
Ps ∈ { sets of components compatible with ψ }

DEF(Pᵢ)  = { db | ∃Ps={P₁ ... Pᵢ₋₁, Pᵢ₊₁ ... Pₙ}. ⋈(Ps ∪ {Pᵢ}) ⇓ db }
DEF(Ps) = ⋂ { DEF(Pᵢ)  | Pᵢ ∈ Pₛ }
DEF     = ⋃ { DEF(Ps) | ∃ Ps } = { db | ∃Ps. db ∈ DEF(Ps) }
UNDEF(Pᵢ) = { ub(t₁,Pᵢ) | ∃ db(t) ∈ DEF(Pᵢ) /\ t=t₁at₂ /\ a∈Pᵢ }
UNDEF(Ps) = ⋂ { UNDEF(Pᵢ) | Pᵢ∈Ps}
UNDEF = ⋃ { UNDEF(Ps) | ∃Ps }

refDef(ub(t,Pᵢ)) = { db(t;t₂) | db(t;t₂) ∈ DEF }

SCL: A property πᵢ is suffix closed or refDef closed iff
     ∀ ub(t,Pᵢ) ∈πᵢ => refDef(ub(t,Pᵢ)) ∈πᵢ
Corollary: if πᵢ is SCL => πᵢ ∈ DEF ∪ UNDEF(Pᵢ)
if Pᵢ is defined then πᵢ ∈ DEF(Pᵢ)
if Pᵢ is undefined then πᵢ ∈ DEF ∪ UNDEF(Pᵢ)

example:
a component Cᵥ is verified and has an event yes, fired when a user
replies positively, and an event bomb.
Property π states that 'bomb' happens only after the action 'yes'. 
Cᵥ is linked with a component Cᵤ unverified which causes ub. We want
to preserve π.

**** Properties over traces
We now define properties Πᵢ over the traces of a component.
Each element in t is tagged with a component Pᵢ
filter(t,Pᵢ) = List.filter(fun (e,Pⱼ) -> Pᵢ=Pⱼ, t)

We can define the πᵢ from our Πᵢ
πᵢ = { b(t) | filter(t,Pᵢ) ∈ Πᵢ }

Note: the only properties that can be defined over a partial program
with UB are those that assumes that the program doesn't UB before a
certain length, starting from some of its entrypoints.

πᵢ = { ub(t) | |filter(t,Pᵢ)|>10 }

*** Properties for sets of component
We now define properties Π over the traces of a set of components.
Each element in t is tagged with a component Pᵢ
filter(t,Ps) = List.filter(fun (e,Pⱼ) -> Pⱼ∈Ps, t)

We can define the π from our Π
π = { b(t) | filter(t,Ps) ∈ Π }

example:
The property requires that component C₁ asks for permission and only
if the event is 'yes' calls C₂.bomb. C₁ and C₂ are verified and linked
with more components that are not.
In our instance the interfaces would allow only C₁ to call C₂.bomb and
even if the other have undefined behavior the property is preserved.
If C₁ or C₂ have ub then the property is true only for a prefix.

**** Special case from properties of single components
π = ⋂ πᵢ
π ∈ DEF ∪ UNDEF
if Ps is defined then π ∈ DEF(Ps)
if Pᵢ is undefined then πᵢ ∈ DEF ∪ UNDEF(Pᵢ)

* Satisfaction and its preservation for whole programs
  P satisfies a property π iff
  P ⇓ b => b ∈ π

  Preservation of satisfaction
  P satisfies π => P↓ satisfies π

  Note that π can be open like in CompCert or closed wrt to DEF, this
  leads to different definitions of compiler correctness.

* Compiler Correctness
** Open properties
Compiler Correctness is generally stated in terms of simulations. CompCert, for
instance, defines it as a backward simulation with refinement. The refinement
part is important because it permits to model several peculiarities of the C
language, e.g. the presence of undefined behaviors at the source language.

CCR (Compiler Correctness with Refinement):
  ∀ b. P↓ ⇓ db => P ⇓ db
                ∨ P ⇓ ub(prefix(db))

By looking carefully at what this definitions says, we can notice that at the
low level we are guaranteed to observe either the same source level behavior of
the original program or a prefix of a source level trace terminated with
undefined behavior. Basically, the second case tells us that we cannot rely on
what happen after an undefined behavior, i.e. the refinement that takes place at
the low level is arbitrary.

Thm: CCR => Preservation of satisfaction

** Closed properties
*** Vertical definability
VDEF: P ⇓ₜ b => ∃P'. P'⇓ₛ b

In principle there is no need to talk about compilation, definability
can be seen as a property of the behaviors that we chose to link the
two semantics. It is true for every program.
We can weaken it and prove it only for compiled programs, probably
useful is Nora's backend. In that case only compiled programs can be
backmapped. Def without CC means that ↓ can compile a program P like
it was another program P'. The compiler in general will never produce
something that is not expressable in the source, independently of what
program you start with.

Some simple implications:
CCR + (V?)DEF => CCRD
*** Compiler Correctness with definability
A possible way to limit the damage caused by undefined behaviors could be to say
something more about the refinement. The idea is to constrain it to what is
possible at the source level.

CCRD:
  ∀ b. P↓ ⇓ db => P ⇓ db
                ∨ (P ⇓ ub(prefix(db)) ∧ ∃ P'. P' ⇓ db)

With this new definition we are limiting the possible refinements so that they
must be reproducible at the source level by an arbitrary program. This property,
however, could be unsatisfactory depending on how expressive the behaviors are.
For instance, we conjecture that CompCert already satisfies it, because its
events are too coarse and we should always be able to exhibit a legal high-level
program that produces them.

Thm: CCRD => Preservation of satisfaction
[CH: Don't really see this. What about the 2nd branch of the or above?]

* Robust Satisfaction and its preservation for linked programs
First of all, we must introduce the notions of linking and separate compilation.

Linking:
  Given components C and P, their linking is represented as ⋈(C, P)
TODO define better

Separate Compilation
SC: ⋈(P₁,...,Pₙ)↓ ⇓b => ⋈(P₁↓,...,Pₙ↓) ⇓b
in our instance this seems to hold by definition because compiling a
whole program consists in concatenating the compilation of its
components: ⋈(P₁,...,Pₙ)↓ = ⋈(P₁↓,...,Pₙ↓).
However in general this might not be true, it looks provable
semantically if we show that we can do a n-way-decomposition to n
partial Pᵢ and then a n-way-composition to get back to P.
TODO recheck this

RS Robust Satisfaction
P robustly satisfies property π iff
  ∀C. C[P]⇓b => b∈π

Robust Satisfaction is defined independently of the existence of a compiler
between different languages. In our case, however, we are interested in
preserving it after we have done a compilation pass on our program.  

PRS (Preservation of Robust Satisfaction):
  (∀C b. C[P]⇓b => b∈π) => (∀c b. c[P↓]⇓b => b∈π)

Note that P and C are sets of components.

An additional definition that we need is the one which allows us to deal with
verified programs that can never exhibit undefined behaviors.
[CH: This remark seems completely out of context. Need for what?]

* Robust Compilation (OLD_RC_DC)

RC: ∀c defined. c[P↓] ⇓ₜ db => ∃C. C[P] ⇓ₛ db \/ C[P] ⇓ₛ ub(pref(db),P)

** why this definition
Starting from CCR and CCRD we can obtain the equivalent for a
component using the partial semantics.

Partial Compiler Correctness Backward and Refined
PCCR: P↓ ⇓ᵢ{C} b => P ⇓ₛ{C} db \/ P ⇓ₛ{C} ub(pref(b),P)
Partial Compilee Correctness Backward and Defined
PCCRD: P↓ ⇓ᵢ{C} b => P ⇓ₛ{C} db \/ (P ⇓ₛ{C} ub(pref(b),P) /\ ∃P'. P' ⇓ₛ{C} db)  

We can go back to complete semantics obtaining the following
RC:  ∀c FD. c[P↓] ⇓ᵢ db => ∃C. C[P] ⇓ₛ db \/ C[P] ⇓ₛ ub(pref(b),P)
RCD: ∀c FD. c[P↓] ⇓ᵢ db => ∃C. C[P] ⇓ₛ db \/ (C[P] ⇓ₛ ub(pref(b),P) /\ ∃P'. C[P'] ⇓ₛ db)

TODO should C be defined or fully defined?

** proof of RC for our instance from T to S
∀c. c[P↓] ⇓ₜ db =>DEC
P↓ ⇓ₜ{C} db =>PCCR 
P ⇓ₛ{C} b' /\ (b'=db \/ b'=ub(pref(db),P) =>DEF in both cases
∃C. C[P] ⇓ₛ b' /\ (b'=db \/ b'=ub(pref(db),P)

** proof of RC for our instance from I to S
   it can be proved with the huge assumption that c is defined, this
   however doesn't influence preservation of properties.

   TODO: RC_IT + RC_SI => RC_ST

** proof that RC (plus other stuff) satisfies PRS
TODO the following proof is valid for open or closed π, we just need
the extra definability for the closed case.

*** RC implies PRS from S to T for πᵢ
Preservation of RS
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c. c[P↓] ⇓ₜ b => b∈πₚ)

Proof using RC+SCL
note that:
- the proof needs the assumption that c is defined to apply RC and this
  is true because we are at the target
- the proof works also if P↓ does ub, even if at the target it doesn't.

Assume h1: (∀b C. C[P] ⇓ₛ b => b∈π)
       h2:  ∀b c. c[P↓] ⇓ₜ b
- c no ub, P↓ no ub, P no ref
- c no ub, P↓ ub, P no ref
h2 =>RC4
∃C. C[P] ⇓ₛ b =>h1
b∈π
- c no ub, P↓ no ub, P ref
- c no ub, P↓ ub, P ref
h2 =>RC4
∃C. C[P] ⇓ₛ ub(pref(b),P) =>h1
ub(pref(b),P) ∈π =>SCL
b∈π

*** RC implies PRS from S to I
Preservation of RS given by RC and Presevation of Closed properties
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c defined. c[P↓] ⇓ᵢ b => b∈πₚ)

PRS:
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c. c[P↓] ⇓ᵢ b => b∈πₚ)

Proof 1
Preservation of RC
(∀b C. C[P] ⇓ₛ b => b∈πₚ) =>
(∀b c defined. c[P↓] ⇓ᵢ b => b∈πₚ)

Satisfaction of closed properties
(∀b c defined. c[P↓] ⇓ᵢ b => b∈πₚ) => (∀b c. c[P↓] ⇓ᵢ b => b∈πₚ)

In general this is not true, for example if ub(t,C) ∉ πₚ the premise
is true but not the conclusion.
However if we apply some filtering or transformation in π it can be
satisfied:
- fix 1
π(b) = { b(t) | Π(t) }

- fix 2
πₚ(b) = { b(t) | filter(t,P) ∈ Π}


TODO

*** HR notes
HR is necessary for the refinements of C and it's the reason it makes
sense to do DECR.

HR: ∀C. C[P]⇓b(t) => ∃C' defined. C'[P]⇓b'(t) /\ b'≠ub(t,C')     (most general)
    ∀C. C[P]⇓ub(t,C) => ∃C' defined. C'[P]⇓term(t,C')            (most specific)

Other versions:
    ∀C. C[P]⇓b(t) /\ b∈π => ∃C' defined. C'[P]⇓b(t) /\ db∈π
    ∀C. C[P]⇓b => ∃C' defined. C'[P]⇓b' /\ filter(b)=filter(b')
    ∀C. C[P]⇓b /\ b∈π => ∃C' FD. C'[P]⇓b' /\ b'≥b /\ b'∈π

TODO HR Proof
looks like a DECR and DEF at the same level
I could use DECR but I'd like to have a b' which is not longer that b,
ideally I can make a C' that instead of doing ub, as soon as it is
called terminates. This leads to the same filtering for b.
TODO if you have RC_SI and RC_IT it looks like you get HR, is it
related to compositionality?


SCL is necessary for the refinements of P
SCL: A property π is suffix closed or refDef closed iff
     ∀ ub(t,P) ∈π => refDef(ub(t,P)) ∈π

TODO: does SCL imply HR ??

** VDEF and RC
   RCD: ∀c defined. c[P↓] ⇓ₜ db => ∃C. C[P] ⇓ₛ db \/ (C[P] ⇓ₛ ub(pref(db),P) /\ ∃P'. C[P'] ⇓ₛ db)
   
   is this necessary to restrict refinements to DEF?
   It looks like it could be obtained from two rounds of RC.

** proof RC implies CCR - TODO

THIS SEEMS TO NEED RC FOR ALL SUBSETS

Proof.
n-DEC for all Pᵢ↓
PCCRD for all Pᵢ↓
n-COMP to obtain the shortest prefix of all ub(pref(b),Pᵢ)


C↓P↓ ⇓b => CP ⇓b ‌\/ CP ⇓ub(pref(b),C) \/ CP ⇓ub(pref(b),p) 



RC4(P, cs, db) = ∃Cs. ⋈(Cs,P) ⇓ₛ db \/ ⋈(Cs,P) ⇓ₛ ub(pref(db),P)
H1: ∀Pᵢ. RC4(Pᵢ, (P\Pᵢ)↓, db)
H2: ∀ b. P↓ ⇓ db
GOAL: P ⇓ db ∨ P ⇓ ub(prefix(db),Pᵢ)


H2=⋈(P₁,...,Pₙ)↓ ⇓ₜ db =>SC
⋈(P₁↓,...,Pₙ↓) ⇓ₜ db =>H1
∃Csᵢ.
(1) ⋈(Csᵢ,Pᵢ) ⇓ₛ db ‌\/
(2) ⋈(Csᵢ,Pᵢ) ⇓ₛ ub(pref(db),Pᵢ)

⋈(Csᵢ, Pᵢ)↓ ⇓ db'

Suppose ↓ is wrong, then either:
1) ⋈(Csᵢ, Pᵢ) ⇓ db
   db'  ≠ db
2) ⋈(Csᵢ, Pᵢ) ⇓ ub(t, Pᵢ)
   ¬∃ prefix(db') = t

(∀Pᵢ. ∃Csᵢ. ⋈(Csᵢ,Pᵢ) ⇓ₛ db 

* Robust Execution (variant of NEW_RC_DC)
What we would like to have is something finer-grained that, ideally, replaces
only those components which cause problems.

RE (Robust Execution):
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
Notes:
  – ρ is a low level program
  – compiler correctness seems to be not required
  – NEW_RC_DC can be obtained by instantiating ρ with both compiled (P) and
    arbitrary (C) components and then looking just at the backmapping of C
  – this property is more general, since it works for arbitrary low level
    components. My intuition is that our environment of execution guarantees the
    backmapping argument for every component, no matter where it comes from
    (e.g. compiled or hand-written).

[CH: not sure about the "more general" part, NEW_RC_DC was stated for
     arbitrary programs and contexts, which is already more general
     than the sets of components model.]
[CH: also, I don't see the fact that this property is n-ary as a plus,
     on the contrary, it seems like a pain]
[CH: finally, could it be that NEW_RC_DC => RE direction also holds?
     I simply take pᵢ to be c and ρ\pᵢ to be P.]

Lemma:
  RE => NEW_RC_DC
Proof:
  Given an arbitrary low level component c and a source level component P, we
  want to show that
    c[P↓] ⇓ b  ⇒  ∃C. FD(C) ∧ C↓[P↓] ⇓ b
  That is, we observed c[P↓] ⇓ b and we need to exhibit a source level component
  C such that
    C fully defined ∧ C↓[P↓] ⇓ b
  by RE instantiated with c and P↓, we can pick the case in which we backmap c
    ∃ C. FD(C) ∧ C↓[P↓] ⇓ b

  [CH: In the NEW_RC_DC instance for components I would expect both c
       and P to be *sets* of components. ]

Lemma:
  CCR ∧ RE => RC4
Proof:
  should follow from multiple applications of RE and then CCR

** Preservation of Robust Satisfaction by means of CCR and RE

[CH: Isn't this just a consequence of:
  (0) RE => NEW_RC_DC
  (1) NEW_RC_DC + CCR => OLD_RC_DC (super simple)
  (2) OLD_RC_DC => PRS (super simple too, counterpositive) ]

Main Theorem:
  CCR ∧ RE => PRS
Notes:
  if we prove that our compiler is correct (CCR) and that our execution
  environment is robust (RE), then it means that robust satisfaction is
  preserved no matter what other components do (e.g. undefined behavior)
Proof:
  Given a source level component P and a property Πₚ, we want to show PRS:
  We know that RS holds at the source level
    ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
           (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P))).
  Given arbitrary c (sets of low level components) and b such that ⋈(c, P↓) ⇓ b,
  we have to show that Πₚ(filter(b, P))

  by RE instantiated with cᵢ ∈ c and P↓, we can pick the case in which we backmap cᵢ
    ∃ Cᵢ. FD(Cᵢ) ∧ ⋈(c\cᵢ, Cᵢ↓, P↓) ⇓ b
  we can do this last thing repeatedly for all the cᵢ ∈ c, until we have all Cᵢ such
  that ∀ i. FD(Cᵢ) ∧ ⋈(C₁↓, ..., Cₙ↓, P↓) ⇓ b
  For brevity, C = {C₁, ..., Cₙ}
  by Separate Compilation
    ⋈(C, P)↓ ⇓ b
  by CCR, three cases
    1) ⋈(C, P) ⇓ b
       by RS at the source we have Πₚ(filter(trace(b), P)), our goal
    2) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, C)
       This cannot happen, since ∀ i. FD(Cᵢ)
    3) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, P)
       by RS at the source we have ∀ ref. Πₚ(filter(pref;ref, P))
       we can destruct trace(b) as trace(b)=pref;t
       then we can instantiate ref with t and obtain Πₚ(filter(pref;t), P)
       this means Πₚ(filter(trace(b), P)), our goal
** Our Instance
Proving RE in our context requires different ingredients:
  1) Partial Semantics
  1) Decomposition:
     A whole program can be simulated by the very same program without some
     components in the partial semantics.
  2) Composition:
     Two compatible partial programs that have the same behavior in
     the partial semantics can be simulated in the complete semantics by a whole
     program obtained by merging them.
  3) Component Definability:
     Given a behavior observed at the low level, we can exhibit a fully defined
     source component which exactly reproduces it.
  4) Forward Compiler Correctness for partial programs:
     The compiler preserves the program semantics when we are in the partial
     semantics.

Decomposition and Composition are simulations which should be provable.

Compiler Correctness for partial programs should follow from CCR.

Definability is definitely the most difficult one. For finite traces we should
be able to prove it, but for the infinite ones we have no clue about how to
proceed. A possibility could be to give guarantees on all the finite traces that
are prefix of an infinite behavior.

*** Proof
We want to show that
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
That is, we have ρ such that ⋈(ρ) ⇓ b and we want to show
  ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
We show the above fact for an arbitrary pᵢ ∈ ρ.
by Decomposition
  pᵢ ⇓{p\pᵢ} b
by Definability
  ∃ Pᵢ. FD(Pᵢ) ∧ Pᵢ ⇓{ρ\pᵢ} b
by Forward Compiler Correctness for partial programs
  Pᵢ↓ ⇓{ρ\pᵢ} b
by Decomposition
  ⋈(p\pᵢ) ⇓{pᵢ} b
by Composition
  ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
we have that
  ∃ Pᵢ FD(Pᵢ) ∧ ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
  which is what we wanted to show.
* Mutual Distrust for πᵢ (broken variant of RC_DC+MD?)
An interesting case is the one with more than two mutually distrustful source
level components. There are several characterization of it, the iterative one
being the most promising.

RC4(P, cs, db) = ∃Cs. ⋈(Cs,P) ⇓ₛ db \/ ⋈(Cs,P) ⇓ₛ ub(pref(db),P)

MD:
P = {P₁, ..., Pₙ}
⋈(P)↓ ⇓ b => ∀ Pᵢ. RC4(Pᵢ, (P\Pᵢ)↓, b)

[CH: I don't see any iteration here, RC4 is not recursive!?]

* Mutual Distrust for π (related to less iterative variants RC_DC+MD' and RC_DC+MD''?)

RC4(Ps, cs, db) = ∃Cs. ⋈(Cs,Ps) ⇓ₛ db \/ ∃Pᵢ. ⋈(Cs,Ps) ⇓ₛ ub(pref(db),Pᵢ)

MD:
P = {P₁, ..., Pₙ}   Ps ∈ subsets(P)
⋈(P)↓ ⇓ b => ∀ Ps. RC4(Ps, (P\Ps)↓, b)
  
* Bits and pieces
** Partial Definability
PDEF: PP ⇓ₜ b  => ∃PP'. PP'⇓ₛ b
PDEF on all components implies DEF on whole programs: WP ⇓ₜ b  =>? ∃WP'. WP'⇓ₛ b
WP ⇓ₜ b => ⋈(p₁,...,pₙ) ⇓ₜ b 
       =>DEC ∀pᵢ. pᵢ ⇓pt b 
       =>PDef ∀pᵢ. ∃Pᵢ'. Pᵢ' ⇓ps b 
       =>COMP ⋈(P₁',...,Pₙ') ⇓ₛ b 
       => WP'⇓ₛ b
TODO: If there is UB in b (e.g. if we are at intermediate instead of
target) then we need to use DECR and recheck the proof

** De/composition with refinement
If we want to have UB in a language then we need to add refinement to its decomposition.
If the context does UB then the partial context refines it.
DECR: ∀C. C[P] ⇓ b => P ⇓{C} b' /\ (b'=b ‌\/ b=pref(b');UB(C))       (note that P can do UB, there is no refinement for P)

Simmetrically we defined composition with a refinement:
COMPR: C ⇓{P} b /\ P ⇓{C} b => C[P] ⇓ b \/ C[P] ⇓ pref(b);UB
TODO CHECK ALL UB CASES

Definability on the same level (the old definability):
DEFS: P ⇓{C} b => ∃C. C[P] ⇓ b      (on the Same level. P can do UB and C cannot)

** Preservation of Robust Satisfaction by means of CCR and RE
Main Theorem:
  CCR ∧ RE => PRS
Notes:
  if we prove that our compiler is correct (CCR) and that our execution
  environment is robust (RE), then it means that robust satisfaction is
  preserved no matter what other components do (e.g. undefined behavior)
Proof:
  Given a source level component P and a property Πₚ, we want to show PRS:
  We know that RS holds at the source level
    ∀ C b. (⋈(C, P) ⇓ b => Πₚ(filter(trace(b), P))) ∨
           (⋈(C, P) ⇓ GoingWrong(t, P) => ∀ ref. Πₚ(filter(t;ref, P))).
  Given arbitrary c (sets of low level components) and b such that ⋈(c, P↓) ⇓ b,
  we have to show that Πₚ(filter(b, P))

  by RE instantiated with cᵢ ∈ c and P↓, we can pick the case in which we backmap cᵢ
    ∃ Cᵢ. FD(Cᵢ) ∧ ⋈(c\cᵢ, Cᵢ↓, P↓) ⇓ b
  we can do this last thing repeatedly for all the cᵢ ∈ c, until we have all Cᵢ such
  that ∀ i. FD(Cᵢ) ∧ ⋈(C₁↓, ..., Cₙ↓, P↓) ⇓ b
  For brevity, C = {C₁, ..., Cₙ}
  by Separate Compilation
    ⋈(C, P)↓ ⇓ b
  by CCR, three cases
    1) ⋈(C, P) ⇓ b
       by RS at the source we have Πₚ(filter(trace(b), P)), our goal
    2) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, C)
       This cannot happen, since ∀ i. FD(Cᵢ)
    3) ∃ pref ∈ prefixes(trace(b)). ⋈(C, P) ⇓ GoingWrong(pref, P)
       by RS at the source we have ∀ ref. Πₚ(filter(pref;ref, P))
       we can destruct trace(b) as trace(b)=pref;t
       then we can instantiate ref with t and obtain Πₚ(filter(pref;t), P)
       this means Πₚ(filter(trace(b), P)), our goal
** Our Instance
Proving RE in our context requires different ingredients:
  1) Partial Semantics
  1) Decomposition:
     A whole program can be simulated by the very same program without some
     components in the partial semantics.
  2) Composition:
     Two compatible partial programs that have the same behavior in
     the partial semantics can be simulated in the complete semantics by a whole
     program obtained by merging them.
  3) Component Definability:
     Given a behavior observed at the low level, we can exhibit a fully defined
     source component which exactly reproduces it.
  4) Forward Compiler Correctness for partial programs:
     The compiler preserves the program semantics when we are in the partial
     semantics.

Decomposition and Composition are simulations which should be provable.

Compiler Correctness for partial programs should follow from CCR.

Definability is definitely the most difficult one. For finite traces we should
be able to prove it, but for the infinite ones we have no clue about how to
proceed. A possibility could be to give guarantees on all the finite traces that
are prefix of an infinite behavior.

*** Proof
We want to show that
  ∀ ρ={p₁,...,pₙ}. ⋈(ρ) ⇓ b => ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
That is, we have ρ such that ⋈(ρ) ⇓ b and we want to show
  ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b
We show the above fact for an arbitrary pᵢ ∈ ρ.
by Decomposition
  pᵢ ⇓{p\pᵢ} b
by Definability
  ∃ Pᵢ. FD(Pᵢ) ∧ Pᵢ ⇓{ρ\pᵢ} b
by Forward Compiler Correctness for partial programs
  Pᵢ↓ ⇓{ρ\pᵢ} b
by Decomposition
  ⋈(p\pᵢ) ⇓{pᵢ} b
by Composition
  ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
we have that
  ∃ Pᵢ FD(Pᵢ) ∧ ⋈(p\pᵢ ∪ Pᵢ↓) ⇓ b
which is what we wanted to show.
** Catalin's example Guglielmo
Now that we have the main ingredients for talking about security, we can see
why CCR and CCRD are not enough to allow this kind of preservation:

  Consider TC and UC as, respectively, trusted and untrusted source level components.

  TC is verified, meaning that it is fully defined, FD(TC), and it robusty
  satisfies a property Πₜ.

  UC is not verified, thus it could exhibit undefined behavior at any point
  during its execution.

  Claim:
    CCRD doesn't guarantee PRS
  Proof:
    Let's suppose to have observed ¬Πₜ(filter(trace(b_bad),P)) at the low level after having
    compiled down TC and UC.
      ⋈(TC↓, UC↓) ⇓ b_bad
    by Separate Compilation
      ⋈(TC, UC)↓ ⇓ b_bad
    by CCRD, two cases
      1) ⋈(TC, UC) ⇓ b_bad
         by Robust Satisfaction
           ⋈(TC, UC) ⇓ b_bad => Πₜ(filter(trace(b_bad), P))
         but we know that ¬Πₜ(filter(trace(b_bad), P)), hence this case cannot happen.
      2) ∃ pref ∈ prefixes(trace(b_bad)). ⋈(TC, UC) ⇓ GoingWrong(pref) ∧ ∃ P'. P' ⇓ b_bad
         Firstly, notice that the undefined behavior could have only happend
         because of UC, since FD(TC).
         by Robust Satisfaction
           ⋈(TC, UC) ⇓ GoingWrong(pref, C) =>
             Πₜ(filter(trace(GoingWrong(pref, C)), P) => Πₜ(filter(pref, P))
         therefore, it must be the case that Πₜ(filter(pref, P)) and the bad things
         characterizing b_bad happen after the undefined behavior at the source level.
         we have been able to observe a bad behavior of P at the low level, even
         if P was verified!
** Catalin's example Marco
Applying DEF and CCBR to the whole program is not enough to prevent a
bad behavior.
It is possible to have a bad behavior at the target if we use only
CCBR, as a result of a refinement:
⋈(Ctrusted, Cuntrusted)↓ ⇓ₜ b_bad =>CCBR
let P=⋈(Ctrusted, Cuntrusted) in P ⇓ₛ b \/ P ⇓ₛ pref(b);UB(Cuntrusted)
And that behavior can be picked up by definability.
⋈(Ctrusted, Cuntrusted)↓ ⇓ₜ b_bad ⇒ ∃P'. P' ⇓ₛ b_bad
The intuition is that an UB in any component makes the others lose
guarantees, even if they are f.d.

We need to apply a finer notion, PCCBR.
The intuition is that because we have correct compilation the
behaviors at target cannot be bad, so the example doesn't apply.
P FD and robustly satisfies π: ∀C. C[P] ⇓b => b ∈ π(P)
b_bad ∉ π(P)
C↓[P↓] ⇓ₜ b_bad
=>DEC P↓ ⇓ₜ{C} b_bad
=>PCCBR P ⇓ₛ{C} b_bad   (because P is verified we can do only one case)
=>DEFS ∃C'. C'[P] ⇓ₛ b_bad
This is a contradiction because P robustly satisfies π.

The same holds from intermediate with UB
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBR P ⇓ₛ{C} b' (because P is verified we can do only one case)
=>DEFS ∃C'. C'[P] ⇓ₛ b'
This should be a contradiction because if b_bad is not in π, the same
should hold for any of its refinements.



P unverified
C↓[P↓] ⇓ₜ b_bad
=>DEC P↓ ⇓ₜ{C} b_bad
=>PCCBR P ⇓ₛ{C} b_bad \/ P ⇓ₛ{C} pref(b_bad);UB(P) 
=>DEFS ∃C'. C'[P] ⇓ₛ pref(b_bad);UB(P)
we can guarantee up to the pref(b_bad).



What if P is not verified?
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBR P ⇓ₛ{C} b'' /\ (b''=b' \/ b''=pref(b');UB(P))
=>DEFS ∃C'. C'[P] ⇓ₛ ??
Is this a contradiction? What is the connection between b_bad and b''?


What if P is not verified and we use PCCBD?
C↓[P↓] ⇓ᵢ b_bad
=>DECR P↓ ⇓ᵢ{C} b' /\ (b'=b_bad ‌\/ b_bad=pref(b');UB(C))
=>PCCBD P ⇓ₛ{C} b' \/ (P ⇓ₛ{C} pref(b');UB(P) /\ ∃P'. P' ⇓ₛ{C} b)
left=>DEFS ∃C'. C'[P] ⇓ₛ b'??
right=>DEFS ∃C'. C'[P] ⇓ₛ b'??

Is this a contradiction? What is the connection between b_bad and b''?

** fully definedness
FD (Fully Definedness):
  ∀ C b. ¬ (⋈(C, P) ⇓ GoingWrong(b))
TODO in many cases we might need only definedness for a specific behavior b

* Robust Execution with Undefined Behavior at target
RE (Robust Execution):
  ∀ ρ={p₁,...,pₙ}.
    (⋈(ρ) ⇓ b =>
      ∀ pᵢ. ∃ Pᵢ. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b) ∨
    (⋈(ρ) ⇓ GoingWrong(t, pᵢ) =>
      (∀ pⱼ s.t. j ≠ i. ∃ Pⱼ. FD(Pⱼ) ∧ ⋈(ρ\pⱼ ∪ Pⱼ↓) ⇓ GoingWrong(t, pᵢ)) ∧
      (∃ Pᵢ b'. FD(Pᵢ) ∧ ⋈(ρ\pᵢ ∪ Pᵢ↓) ⇓ b' ∧ trace(b') = t)
* again
Proof and definition become more detailed, which means clearer but also harder to read.
The π contains only DEF and it's much clearer.

** Robust Satisfaction:
  P robustly satisfies π ⊆ DEF
  ∀P b C. C[P]⇓b => ∃t.
  (b=db(t) => db(t) ∈ π) /\
  (b=ub(t,C) => ∃db(t') ∈ π /\ t≤t') /\
  (b=ub(t,P) => ∀t'. t≤t' /\ db(t') ∈ π)

  Note that satisfaction for whole programs is an instance with an
  empty C and the second match doesn't occur.

** Preservation of RS:
  RS_L1(P) => RS_L2(P↓)
** RC+HR => PRS_SI

Assume
  HR: ∀C. C[P]⇓b(t) => ∃C' defined. C'[P]⇓b'(t) /\ b'≠ub(t,C')

Assume h1 
  ∀P tₛ C. C[P]⇓ₛ b(tₛ) =>
  (b(tₛ)=db(t) => db(tₛ) ∈ π) /\
  (b(tₛ)=ub(tₛ,C) => ∃db(tₛ') ∈ π /\ tₛ≤tₛ') /\
  (b(tₛ)=ub(tₛ,P) => ∀tₛ'. tₛ≤tₛ' /\ db(tₛ') ∈ π)

Assume h2
  ∀P tᵢ c. c[P↓]⇓ᵢb(tᵢ)

Goal
  (b(tᵢ)=db(tᵢ) => db(tᵢ) ∈ π) /\
  (b(tᵢ)=ub(tᵢ,c) => ∃db(tᵢ') ∈ π /\ tᵢ≤tᵢ') /\
  (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)


i) c no ub, P↓ no ub, P ref/no ref
h2: c[P↓]⇓ᵢdb(tᵢ) =>RC4
∃C. C[P] ⇓ₛ b(tᵢ)
1) C[P] ⇓ₛ db(tᵢ)
by RS db(tᵢ) ∈ π
2) C[P] ⇓ₛ ub(prefix(tᵢ), P)
To show
    (b(tᵢ)=ub(tᵢ,P↓) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)
by RS ∀tᵢ'. prefix(tᵢ)≤tᵢ' /\ db(tᵢ') ∈ π

ii) c no ub, P↓ ub, P ref/no ref
h2: c[P↓]⇓ᵢub(tᵢ,P) =>RC4
∃C.
1) C[P] ⇓ₛ ub(tᵢ,P)
To show:
  (b=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)
by RS: ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π
2) C[P] ⇓ₛ ub(prefix(tᵢ), P)
To show:
  (b=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)
by RS ub(prefix(tᵢ),P) => ∀ tᵢ'. prefix(tᵢ)≤tᵢ' /\ db(tᵢ') ∈ π

iii) c ub, P↓ no ub, P ref/no ref
h2: c[P↓]⇓ᵢub(tᵢ,C) =>HR
∃b' c' defined. c'[P↓]⇓ᵢb'(tᵢ) /\ b'≠ub(tᵢ,c') =>RC4
by i) or ii)

** RC => PRS_IT
   is a special case of the previous proof
** RC_SI + RC_IT => RC_ST
   interesting?
** PSR_SI + PSR_IT => PSR_ST
Assume PRS_SI
  (∀P tₛ C. C[P]⇓ₛ b(tₛ) =>
   (b(tₛ)=db(t) => db(tₛ) ∈ π) /\
   (b(tₛ)=ub(tₛ,C) => ∃db(tₛ') ∈ π /\ tₛ≤tₛ') /\
   (b(tₛ)=ub(tₛ,P) => ∀tₛ'. tₛ≤tₛ' /\ db(tₛ') ∈ π)) =>
  (∀P tᵢ C. C[P↓]⇓ᵢ b(tᵢ) =>
   (b(tᵢ)=db(t) => db(tᵢ) ∈ π) /\
   (b(tᵢ)=ub(tᵢ,C) => ∃db(tᵢ') ∈ π /\ tᵢ≤tᵢ') /\
   (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π))

Assume PRS_IT
  (∀P tᵢ C. C[P]⇓ᵢ b(tᵢ) =>
   (b(tᵢ)=db(t) => db(tᵢ) ∈ π) /\
   (b(tᵢ)=ub(tᵢ,C) => ∃db(tᵢ') ∈ π /\ tᵢ≤tᵢ') /\
   (b(tᵢ)=ub(tᵢ,P) => ∀tᵢ'. tᵢ≤tᵢ' /\ db(tᵢ') ∈ π)) =>
  (∀P tₜ C. C[P↓]⇓ₜ b(tₜ) =>
   (b(tₜ)=db(t) => db(tₜ) ∈ π) /\
   (b(tₜ)=ub(tₜ,C) => ∃db(tₜ') ∈ π /\ tₜ≤tₜ') /\
   (b(tₜ)=ub(tₜ,P) => ∀tₜ'. tₜ≤tₜ' /\ db(tₜ') ∈ π))

Assume
  (∀P tₛ C. C[P]⇓ₛ b(tₛ) =>
   (b(tₛ)=db(t) => db(tₛ) ∈ π) /\
   (b(tₛ)=ub(tₛ,C) => ∃db(tₛ') ∈ π /\ tₛ≤tₛ') /\
   (b(tₛ)=ub(tₛ,P) => ∀tₛ'. tₛ≤tₛ' /\ db(tₛ') ∈ π))

To show
  (∀P tₜ C. C[P↓↓]⇓ₜ b(tₜ) =>
   (b(tₜ)=db(t) => db(tₜ) ∈ π) /\
   (b(tₜ)=ub(tₜ,C) => ∃db(tₜ') ∈ π /\ tₜ≤tₜ') /\
   (b(tₜ)=ub(tₜ,P) => ∀tₜ'. tₜ≤tₜ' /\ db(tₜ') ∈ π))
